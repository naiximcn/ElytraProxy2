From 62168e0b8b1e5ad6b468b5d994a979c711cc5e33 Mon Sep 17 00:00:00 2001
From: mdxd44 <mdxd44@ely.su>
Date: Sat, 29 May 2021 02:33:34 +0900
Subject: [PATCH] New Config System, Add Base Botfilter Code, Fix bugs, Code
 Cleanup And More


diff --git a/HEADER_BOTFILTER.txt b/HEADER_BOTFILTER.txt
new file mode 100644
index 00000000..0176d203
--- /dev/null
+++ b/HEADER_BOTFILTER.txt
@@ -0,0 +1,21 @@
+This file is part of Velocity-BotFilter, licensed under the AGPLv3 License (AGPLv3).
+
+Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo> <https://github.com/BotFilter/Velocity-BotFilter>
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
\ No newline at end of file
diff --git a/HEADER_MCPROTOCOLLIB.txt b/HEADER_MCPROTOCOLLIB.txt
new file mode 100644
index 00000000..bd06f8c7
--- /dev/null
+++ b/HEADER_MCPROTOCOLLIB.txt
@@ -0,0 +1,22 @@
+This file is part of MCProtocolLib, licensed under the MIT License (MIT).
+
+Copyright (c) Steveice10 <https://github.com/Steveice10/MCProtocolLib>
+Copyright (c) contributors
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
\ No newline at end of file
diff --git a/api/src/main/java/com/velocitypowered/api/network/ProtocolVersion.java b/api/src/main/java/com/velocitypowered/api/network/ProtocolVersion.java
index bdddd586..683ab9f1 100644
--- a/api/src/main/java/com/velocitypowered/api/network/ProtocolVersion.java
+++ b/api/src/main/java/com/velocitypowered/api/network/ProtocolVersion.java
@@ -231,6 +231,29 @@ public enum ProtocolVersion {
     return this == LEGACY;
   }
 
+  //BotFilter start
+  public boolean isBefore(ProtocolVersion other) {
+    return this.compareTo(other) < 0;
+  }
+
+  public boolean isBeforeOrEq(ProtocolVersion other) {
+    return this.compareTo(other) <= 0;
+  }
+
+  public boolean isAfter(ProtocolVersion other) {
+    return this.compareTo(other) > 0;
+  }
+
+  public boolean isAfterOrEq(ProtocolVersion other) {
+    return this.compareTo(other) >= 0;
+  }
+  //BotFilter add
+
+  public static ProtocolVersion adapt(int protocol) {
+    return ID_TO_PROTOCOL_CONSTANT.get(protocol);
+  }
+  //BotFilter end
+
   @Override
   public String toString() {
     return getVersionIntroducedIn();
diff --git a/api/src/main/java/com/velocitypowered/api/proxy/config/ProxyConfig.java b/api/src/main/java/com/velocitypowered/api/proxy/config/ProxyConfig.java
index 360d2ba5..262e21bd 100644
--- a/api/src/main/java/com/velocitypowered/api/proxy/config/ProxyConfig.java
+++ b/api/src/main/java/com/velocitypowered/api/proxy/config/ProxyConfig.java
@@ -121,6 +121,13 @@ public interface ProxyConfig {
    */
   int getLoginRatelimit();
 
+  /**
+   * Get the limit for how many times a player must login before rate limit will work.
+   *
+   * @return the max join attempts before rate limiting
+   */
+  int getLoginRatelimitAttempts();
+
   /**
    * Get the proxy favicon shown in the tablist.
    *
diff --git a/build.gradle b/build.gradle
index a322f1c2..54628b5e 100644
--- a/build.gradle
+++ b/build.gradle
@@ -63,6 +63,11 @@ allprojects {
         maven {
             url "https://nexus.velocitypowered.com/repository/maven-public/"
         }
+
+        // BotFilter repo
+        maven {
+            url "https://maven.leymooo.me/repository/public/"
+        }
     }
 
     test {
diff --git a/native/src/main/java/com/velocitypowered/natives/compression/JavaVelocityCompressor.java b/native/src/main/java/com/velocitypowered/natives/compression/JavaVelocityCompressor.java
index e9809f2a..37b994ba 100644
--- a/native/src/main/java/com/velocitypowered/natives/compression/JavaVelocityCompressor.java
+++ b/native/src/main/java/com/velocitypowered/natives/compression/JavaVelocityCompressor.java
@@ -38,6 +38,7 @@ public class JavaVelocityCompressor implements VelocityCompressor {
   private boolean disposed = false;
 
   private JavaVelocityCompressor(int level) {
+    level = Math.min(9, level); //BotFilter
     this.deflater = new Deflater(level);
     this.inflater = new Inflater();
   }
diff --git a/proxy/build.gradle b/proxy/build.gradle
index 165ca840..6d775a0a 100644
--- a/proxy/build.gradle
+++ b/proxy/build.gradle
@@ -2,21 +2,29 @@ import com.github.jengelman.gradle.plugins.shadow.transformers.Log4j2PluginsCach
 
 plugins {
     id 'java'
-    id 'checkstyle'
+//    id 'checkstyle'
 }
 
 apply plugin: 'org.cadixdev.licenser'
-apply from: '../gradle/checkstyle.gradle'
+//apply from: '../gradle/checkstyle.gradle'
 apply plugin: 'com.github.johnrengelman.shadow'
 
 license {
-    matching(includes: ['**/elytraproxy/**', '**/elytraproxy/config/**', '**/default-elytraproxy.yml']) {
+    //matching(includes: ['**/botfilter/**']) {
+    //    header = project.rootProject.file('HEADER_BOTFILTER.txt')
+    //}
+    matching(includes: ['**/mcprotocollib/**']) {
+        header = project.rootProject.file('HEADER_MCPROTOCOLLIB.txt')
+    }
+    matching(includes: ['**/elytraproxy/**']) {
         header = project.rootProject.file('HEADER_ELYTRAPROXY.txt')
     }
-    matching(includes: ['**/ru/elytrium/elytraproxy/commands/ElytraProxyCommand.java']) {
+    matching(includes: ['**/ElytraProxyCommand.java']) {
         header = project.rootProject.file('HEADER.txt')
     }
     header = project.rootProject.file('HEADER.txt')
+    exclude '**/default-elytraproxy.yml'
+    exclude '**/botfilter/**'
 }
 
 jar {
@@ -43,10 +51,19 @@ shadowJar {
 
 tasks.withType(Checkstyle) {
     exclude('**/com/velocitypowered/proxy/protocol/packet/*.java')
-    exclude('**/ru/elytrium/elytraproxy/config/**/*.java')
+    //exclude('**/ru/elytrium/elytraproxy/config/**/*.java')
 }
 
 dependencies {
+    //BotFilter add lombok
+    compileOnly 'org.projectlombok:lombok:1.18.20'
+    annotationProcessor 'org.projectlombok:lombok:1.18.20'
+
+    testCompileOnly 'org.projectlombok:lombok:1.18.20'
+    testAnnotationProcessor 'org.projectlombok:lombok:1.18.20'
+
+    implementation 'redis.clients:jedis:3.6.0'
+    implementation 'com.squareup.okhttp:okhttp:2.7.5'
     // Note: we depend on the API twice, first the main sourceset, and then the annotation processor.
     implementation project(':elytraproxy-api')
     implementation project(':elytraproxy-api').sourceSets.ap.output
@@ -87,11 +104,16 @@ dependencies {
 
     implementation 'com.github.ben-manes.caffeine:caffeine:3.0.2'
 
+    // ElytraProxy - add mysql driver
+    implementation 'org.mariadb.jdbc:mariadb-java-client:2.7.3'
+
     compileOnly 'com.github.spotbugs:spotbugs-annotations:4.1.2'
 
     testImplementation "org.junit.jupiter:junit-jupiter-api:${junitVersion}"
     testImplementation "org.junit.jupiter:junit-jupiter-engine:${junitVersion}"
     testImplementation "org.mockito:mockito-core:3.+"
+
+    implementation 'ru.leymooo:AnnotatedYAMLConfiguration-standalone:1.1-SNAPSHOT' //BotFilter
 }
 
 test {
diff --git a/proxy/src/main/java/com/velocitypowered/proxy/VelocityServer.java b/proxy/src/main/java/com/velocitypowered/proxy/VelocityServer.java
index d9df0bfa..57a1c928 100644
--- a/proxy/src/main/java/com/velocitypowered/proxy/VelocityServer.java
+++ b/proxy/src/main/java/com/velocitypowered/proxy/VelocityServer.java
@@ -91,6 +91,8 @@ import java.util.concurrent.TimeoutException;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.function.IntFunction;
 import java.util.stream.Collectors;
+
+import lombok.Getter;
 import net.kyori.adventure.audience.Audience;
 import net.kyori.adventure.audience.ForwardingAudience;
 import net.kyori.adventure.key.Key;
@@ -106,6 +108,7 @@ import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
 import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.checker.nullness.qual.Nullable;
 import ru.elytrium.elytraproxy.ElytraProxy;
+import ru.elytrium.elytraproxy.config.Settings;
 
 public class VelocityServer implements ProxyServer, ForwardingAudience {
 
@@ -138,13 +141,14 @@ public class VelocityServer implements ProxyServer, ForwardingAudience {
   private final VelocityPluginManager pluginManager;
   private final AdventureBossBarManager bossBarManager;
 
-  private final Map<UUID, ConnectedPlayer> connectionsByUuid = new ConcurrentHashMap<>();
+  public static final Map<UUID, ConnectedPlayer> connectionsByUuid = new ConcurrentHashMap<>();
   private final Map<String, ConnectedPlayer> connectionsByName = new ConcurrentHashMap<>();
   private final VelocityConsole console;
   private @MonotonicNonNull Ratelimiter ipAttemptLimiter;
   private final VelocityEventManager eventManager;
   private final VelocityScheduler scheduler;
   private final VelocityChannelRegistrar channelRegistrar = new VelocityChannelRegistrar();
+  private @MonotonicNonNull ElytraProxy elytraProxy; // ElytraProxy
 
   VelocityServer(final ProxyOptions options) {
     pluginManager = new VelocityPluginManager(this);
@@ -215,11 +219,14 @@ public class VelocityServer implements ProxyServer, ForwardingAudience {
 
     this.doStartupConfigLoad();
 
+    this.elytraProxy = new ElytraProxy(this);
+
     for (Map.Entry<String, String> entry : configuration.getServers().entrySet()) {
       servers.register(new ServerInfo(entry.getKey(), AddressUtil.parseAddress(entry.getValue())));
     }
 
-    ipAttemptLimiter = Ratelimiters.createWithMilliseconds(configuration.getLoginRatelimit());
+    ipAttemptLimiter = Ratelimiters.createWithMilliseconds(configuration.getLoginRatelimit(),
+            configuration.getLoginRatelimitAttempts()); //BotFilter - global rate limiter
     loadPlugins();
 
     // Go ahead and fire the proxy initialization event. We block since plugins should have a chance
@@ -291,10 +298,6 @@ public class VelocityServer implements ProxyServer, ForwardingAudience {
     try {
       Path configPath = Paths.get("velocity.toml");
       configuration = VelocityConfiguration.read(configPath);
-      // ElytraProxy Start - Init ElytraProxy
-      ElytraProxy elytraproxy = ElytraProxy.getInstance();
-      elytraproxy.finishLoad(this);
-      // ElytraProxy End
 
       if (!configuration.validate()) {
         logger.error("Your configuration is invalid. Velocity will not start up until the errors "
@@ -305,7 +308,8 @@ public class VelocityServer implements ProxyServer, ForwardingAudience {
 
       commandManager.setAnnounceProxyCommands(configuration.isAnnounceProxyCommands());
     } catch (Exception e) {
-      logger.error("Unable to read/load/save your velocity.toml. The server will shut down.", e);
+      logger.error("Unable to read/load/save your velocity.toml or elytraproxy.yml."
+              + "The server will shut down.", e);
       LogManager.shutdown();
       System.exit(1);
     }
@@ -442,7 +446,8 @@ public class VelocityServer implements ProxyServer, ForwardingAudience {
     }
 
     commandManager.setAnnounceProxyCommands(newConfiguration.isAnnounceProxyCommands());
-    ipAttemptLimiter = Ratelimiters.createWithMilliseconds(newConfiguration.getLoginRatelimit());
+    ipAttemptLimiter = Ratelimiters.createWithMilliseconds(newConfiguration.getLoginRatelimit(),
+        newConfiguration.getLoginRatelimitAttempts()); //BotFilter - global rate limiter
     this.configuration = newConfiguration;
     eventManager.fireAndForget(new ProxyReloadEvent());
     return true;
@@ -569,7 +574,7 @@ public class VelocityServer implements ProxyServer, ForwardingAudience {
     return !(connectionsByName.containsKey(lowerName)
         || connectionsByUuid.containsKey(connection.getUniqueId()));
   }
-  
+
   /**
    * Attempts to register the {@code connection} with the proxy.
    * @param connection the connection to register
@@ -721,6 +726,10 @@ public class VelocityServer implements ProxyServer, ForwardingAudience {
     return bossBarManager;
   }
 
+  public ElytraProxy getElytraProxy() {
+    return elytraProxy;
+  }
+
   public static Gson getPingGsonInstance(ProtocolVersion version) {
     return version.compareTo(ProtocolVersion.MINECRAFT_1_16) >= 0 ? POST_1_16_PING_SERIALIZER
         : PRE_1_16_PING_SERIALIZER;
diff --git a/proxy/src/main/java/com/velocitypowered/proxy/config/VelocityConfiguration.java b/proxy/src/main/java/com/velocitypowered/proxy/config/VelocityConfiguration.java
index 29dd341b..9863c145 100644
--- a/proxy/src/main/java/com/velocitypowered/proxy/config/VelocityConfiguration.java
+++ b/proxy/src/main/java/com/velocitypowered/proxy/config/VelocityConfiguration.java
@@ -53,6 +53,7 @@ import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
 import org.checkerframework.checker.nullness.qual.Nullable;
+import ru.elytrium.elytraproxy.config.Settings;
 
 public class VelocityConfiguration implements ProxyConfig {
 
@@ -315,6 +316,12 @@ public class VelocityConfiguration implements ProxyConfig {
     return advanced.getLoginRatelimit();
   }
 
+  //BotFilter - global rate limiter
+  @Override
+  public int getLoginRatelimitAttempts() {
+    return Settings.IMP.ANTIBOT.LOGIN_RATELIMIT_ATTEMPTS;
+  }
+
   @Override
   public Optional<Favicon> getFavicon() {
     return Optional.ofNullable(favicon);
diff --git a/proxy/src/main/java/com/velocitypowered/proxy/connection/MinecraftConnection.java b/proxy/src/main/java/com/velocitypowered/proxy/connection/MinecraftConnection.java
index 3f66e244..e457c503 100644
--- a/proxy/src/main/java/com/velocitypowered/proxy/connection/MinecraftConnection.java
+++ b/proxy/src/main/java/com/velocitypowered/proxy/connection/MinecraftConnection.java
@@ -28,6 +28,7 @@ import static com.velocitypowered.proxy.network.Connections.MINECRAFT_ENCODER;
 
 import com.google.common.base.Preconditions;
 import com.velocitypowered.api.network.ProtocolVersion;
+import com.velocitypowered.api.proxy.Player;
 import com.velocitypowered.natives.compression.VelocityCompressor;
 import com.velocitypowered.natives.encryption.VelocityCipher;
 import com.velocitypowered.natives.encryption.VelocityCipherFactory;
@@ -166,8 +167,8 @@ public class MinecraftConnection extends ChannelInboundHandlerAdapter {
     if (ctx.channel().isActive()) {
       if (sessionHandler != null) {
         try {
-          // ElytraProxy Start - Try to fix long message while player disconnect unexpectedly
-          if (cause instanceof ReadTimeoutException) {
+          // ElytraProxy Start - Fix long message while player disconnect unexpectedly
+          if (cause instanceof ReadTimeoutException && association instanceof Player) {
             logger.info("{} –ø—Ä–µ–¥–ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ –≤—ã—à–µ–ª —Å —Å–µ—Ä–≤–µ—Ä–∞ –∑–∞–∫—Ä—ã–≤ –º–∞–π–Ω–∫—Ä–∞—Ñ—Ç.", association);
           } else {
             sessionHandler.exception(cause);
@@ -256,7 +257,8 @@ public class MinecraftConnection extends ChannelInboundHandlerAdapter {
     if (channel.isActive()) {
       boolean is17 = this.getProtocolVersion().compareTo(ProtocolVersion.MINECRAFT_1_8) < 0
           && this.getProtocolVersion().compareTo(ProtocolVersion.MINECRAFT_1_7_2) >= 0;
-      if (is17 && this.getState() != StateRegistry.STATUS) {
+      // BotFilter looks like it works ok for Login protocol
+      if (is17 && this.getState() == StateRegistry.PLAY) {
         channel.eventLoop().execute(() -> {
           // 1.7.x versions have a race condition with switching protocol states, so just explicitly
           // close the connection after a short while.
diff --git a/proxy/src/main/java/com/velocitypowered/proxy/connection/MinecraftSessionHandler.java b/proxy/src/main/java/com/velocitypowered/proxy/connection/MinecraftSessionHandler.java
index e72f42d6..2c6d4375 100644
--- a/proxy/src/main/java/com/velocitypowered/proxy/connection/MinecraftSessionHandler.java
+++ b/proxy/src/main/java/com/velocitypowered/proxy/connection/MinecraftSessionHandler.java
@@ -53,6 +53,7 @@ import com.velocitypowered.proxy.protocol.packet.title.TitleSubtitlePacket;
 import com.velocitypowered.proxy.protocol.packet.title.TitleTextPacket;
 import com.velocitypowered.proxy.protocol.packet.title.TitleTimesPacket;
 import io.netty.buffer.ByteBuf;
+import ru.elytrium.elytraproxy.botfilter.protocol.packet.PlayerPositionAndLook;
 
 public interface MinecraftSessionHandler {
 
@@ -231,4 +232,10 @@ public interface MinecraftSessionHandler {
   default boolean handle(ResourcePackResponse packet) {
     return false;
   }
+
+  //BotFilter start - add handle methods
+  default boolean handle(PlayerPositionAndLook packet) {
+    return false;
+  }
+  //BotFilter end
 }
diff --git a/proxy/src/main/java/com/velocitypowered/proxy/connection/client/HandshakeSessionHandler.java b/proxy/src/main/java/com/velocitypowered/proxy/connection/client/HandshakeSessionHandler.java
index d5468daa..12b6f38f 100644
--- a/proxy/src/main/java/com/velocitypowered/proxy/connection/client/HandshakeSessionHandler.java
+++ b/proxy/src/main/java/com/velocitypowered/proxy/connection/client/HandshakeSessionHandler.java
@@ -125,11 +125,15 @@ public class HandshakeSessionHandler implements MinecraftSessionHandler {
       return;
     }
 
+    //BotFilter start - global rate limiter
+    /*
     InetAddress address = ((InetSocketAddress) connection.getRemoteAddress()).getAddress();
     if (!server.getIpAttemptLimiter().attempt(address)) {
       ic.disconnectQuietly(Component.translatable("velocity.error.logging-in-too-fast"));
       return;
     }
+    */
+    //BotFilter end - global rate limiter
 
     connection.setType(getHandshakeConnectionType(handshake));
 
diff --git a/proxy/src/main/java/com/velocitypowered/proxy/connection/client/LoginSessionHandler.java b/proxy/src/main/java/com/velocitypowered/proxy/connection/client/LoginSessionHandler.java
index a4b3156a..eff9d2de 100644
--- a/proxy/src/main/java/com/velocitypowered/proxy/connection/client/LoginSessionHandler.java
+++ b/proxy/src/main/java/com/velocitypowered/proxy/connection/client/LoginSessionHandler.java
@@ -25,7 +25,6 @@ import static com.velocitypowered.proxy.util.EncryptionUtils.decryptRsa;
 import static com.velocitypowered.proxy.util.EncryptionUtils.generateServerId;
 
 import com.google.common.base.Preconditions;
-import com.google.common.collect.ImmutableMap;
 import com.velocitypowered.api.event.connection.DisconnectEvent;
 import com.velocitypowered.api.event.connection.DisconnectEvent.LoginStatus;
 import com.velocitypowered.api.event.connection.LoginEvent;
@@ -57,7 +56,6 @@ import java.security.GeneralSecurityException;
 import java.security.KeyPair;
 import java.security.MessageDigest;
 import java.util.Arrays;
-import java.util.List;
 import java.util.Optional;
 import java.util.UUID;
 import java.util.concurrent.CompletableFuture;
@@ -71,9 +69,7 @@ import org.apache.logging.log4j.Logger;
 import org.asynchttpclient.ListenableFuture;
 import org.asynchttpclient.Response;
 import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
-import ru.elytrium.elytraproxy.ElytraProxy;
-import ru.elytrium.elytraproxy.config.plugins.AntibotConfig;
-import ru.elytrium.elytraproxy.plugins.skins.SkinSetup;
+import ru.elytrium.elytraproxy.config.Settings;
 
 public class LoginSessionHandler implements MinecraftSessionHandler {
 
@@ -82,7 +78,6 @@ public class LoginSessionHandler implements MinecraftSessionHandler {
       "https://sessionserver.mojang.com/session/minecraft/hasJoined?username=%s&serverId=%s";
 
   private final VelocityServer server;
-  private final ElytraProxy elytraProxy;
   private final MinecraftConnection mcConnection;
   private final InitialInboundConnection inbound;
   private @MonotonicNonNull ServerLogin login;
@@ -94,7 +89,6 @@ public class LoginSessionHandler implements MinecraftSessionHandler {
     this.server = Preconditions.checkNotNull(server, "server");
     this.mcConnection = Preconditions.checkNotNull(mcConnection, "mcConnection");
     this.inbound = Preconditions.checkNotNull(inbound, "inbound");
-    this.elytraProxy = ElytraProxy.getInstance();
   }
 
   @Override
@@ -236,10 +230,10 @@ public class LoginSessionHandler implements MinecraftSessionHandler {
         onlineMode);
     final GameProfile finalProfile = profile;
 
-    server.getEventManager().fire(profileRequestEvent).thenComposeAsync(profileEvent -> {
+    server.getEventManager().fire(profileRequestEvent).thenAcceptAsync(profileEvent -> {
       if (mcConnection.isClosed()) {
-        // The player disconnected after we authenticated them.
-        return CompletableFuture.completedFuture(null);
+        // The player disconnected while event execution
+        return;
       }
 
       // Initiate a regular connection and move over to it.
@@ -249,28 +243,9 @@ public class LoginSessionHandler implements MinecraftSessionHandler {
       if (!server.canRegisterConnection(player)) {
         player.disconnect0(Component.translatable("velocity.error.already-connected-proxy",
             NamedTextColor.RED), true);
-        return CompletableFuture.completedFuture(null);
+        return;
       }
-
-      // ElytraProxy Start - Block popular minecraft botters, Skins system
-      AntibotConfig antibotConfig = elytraProxy.getConfig().getPlugins().antibot;
-
-      if (antibotConfig.enable) {
-        String formattedNickname = player.getUsername().toLowerCase();
-
-        if (antibotConfig.bannedNicknames.stream().anyMatch(formattedNickname::contains)) {
-          player.disconnect0(
-                  Component.text(
-                          "¬ßc–í –≤–∞—à–µ–º –Ω–∏–∫–µ —Å–æ–¥–µ—Ä–∂–∞—Ç—Å—è –∑–∞–ø—Ä–µ—â—ë–Ω–Ω—ã–µ —Ñ—Ä–∞–∑—ã."
-                          + "\n¬ßc–ï—Å–ª–∏ –≤—ã —Å—á–∏—Ç–∞–µ—Ç–µ —á—Ç–æ —ç—Ç–æ –æ—à–∏–±–∫–∞,"
-                          + " —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ü–∏–µ–π. (ely.su/discord)"),
-                          true
-          );
-          logger.info("Firewaled bot {}", player.getUsername());
-          return CompletableFuture.completedFuture(null);
-        }
-      }
-
+      /*
       SkinSetup setup = elytraProxy
               .getDatabase()
               .getItem(
@@ -284,39 +259,52 @@ public class LoginSessionHandler implements MinecraftSessionHandler {
         player.setGameProfileProperties(playerProfile);
 
       }
-      // ElytraProxy End
-
+      */
       logger.info("{} has connected", player);
-
-      return server.getEventManager()
-          .fire(new PermissionsSetupEvent(player, ConnectedPlayer.DEFAULT_PERMISSIONS))
-          .thenAcceptAsync(event -> {
-            if (!mcConnection.isClosed()) {
-              // wait for permissions to load, then set the players permission function
-              final PermissionFunction function = event.createFunction(player);
-              if (function == null) {
-                logger.error(
-                    "A plugin permission provider {} provided an invalid permission function"
-                        + " for player {}. This is a bug in the plugin, not in Velocity. Falling"
-                        + " back to the default permission function.",
-                    event.getProvider().getClass().getName(),
-                    player.getUsername());
-              } else {
-                player.setPermissionFunction(function);
-              }
-              completeLoginProtocolPhaseAndInitialize(player);
-            }
-          }, mcConnection.eventLoop());
+      preLoginCheck(player);
     }, mcConnection.eventLoop()).exceptionally((ex) -> {
       logger.error("Exception during connection of {}", finalProfile, ex);
       return null;
-    });  
+    });
   }
 
-  private void completeLoginProtocolPhaseAndInitialize(ConnectedPlayer player) {
+  private void preLoginCheck(ConnectedPlayer player) {
+    if (Settings.IMP.ANTIBOT.ENABLE) {
+      String formattedNickname = player.getUsername().toLowerCase();
+
+      if (Settings.IMP.ANTIBOT.BANNED_NICK_PATTERNS.stream().anyMatch(formattedNickname::contains)) {
+        player.disconnect0(
+                Component.text(
+                        "¬ßc–í –≤–∞—à–µ–º –Ω–∏–∫–µ —Å–æ–¥–µ—Ä–∂–∞—Ç—Å—è –∑–∞–ø—Ä–µ—â—ë–Ω–Ω—ã–µ —Ñ—Ä–∞–∑—ã."
+                                + "\n¬ßc–ï—Å–ª–∏ –≤—ã —Å—á–∏—Ç–∞–µ—Ç–µ —á—Ç–æ —ç—Ç–æ –æ—à–∏–±–∫–∞,"
+                                + " —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ü–∏–µ–π. (ely.su/discord)"),
+                true
+        );
+        logger.info("Firewaled bot {}", player.getUsername());
+      } else {
+        //injectBotFilterOrFinishLogin(player);
+
+        // temp
+        completeLoginProtocol(player, true);
+        initialize(player);
+      }
+    }
+  }
+
+  private void injectBotFilterOrFinishLogin(ConnectedPlayer player) {
+
+    if (server.getElytraProxy().shouldCheck(player)) {
+      server.getElytraProxy().setupPipelineAndStartCheck(player, this);
+    } else {
+      completeLoginProtocol(player, true);
+      initialize(player);
+    }
+  }
+
+  public void completeLoginProtocol(ConnectedPlayer player, boolean flush) {
     int threshold = server.getConfiguration().getCompressionThreshold();
     if (threshold >= 0 && mcConnection.getProtocolVersion().compareTo(MINECRAFT_1_8) >= 0) {
-      mcConnection.write(new SetCompression(threshold));
+      mcConnection.delayedWrite(new SetCompression(threshold));
       mcConnection.setCompressionThreshold(threshold);
     }
     VelocityConfiguration configuration = server.getConfiguration();
@@ -327,12 +315,35 @@ public class LoginSessionHandler implements MinecraftSessionHandler {
     ServerLoginSuccess success = new ServerLoginSuccess();
     success.setUsername(player.getUsername());
     success.setUuid(playerUniqueId);
-    mcConnection.write(success);
+    mcConnection.delayedWrite(success);
+    if (flush) {
+      mcConnection.flush();
+    }
+  }
+
 
+  public void initialize(ConnectedPlayer player) {
     mcConnection.setAssociation(player);
     mcConnection.setState(StateRegistry.PLAY);
-
-    server.getEventManager().fire(new LoginEvent(player))
+    server.getEventManager()
+        .fire(new PermissionsSetupEvent(player, ConnectedPlayer.DEFAULT_PERMISSIONS))
+        .thenComposeAsync(premissionEvent -> {
+          if (mcConnection.isClosed()) {
+            return CompletableFuture.completedFuture(null);
+          }
+          // wait for permissions to load, then set the players permission function
+          final PermissionFunction function = premissionEvent.createFunction(player);
+          if (function == null) {
+            logger.error(
+                "A plugin permission provider {} provided an invalid permission function"
+                    + " for player {}. This is a bug in the plugin, not in Velocity. Falling"
+                    + " back to the default permission function.",
+                premissionEvent.getProvider().getClass().getName(),
+                player.getUsername());
+          } else {
+            player.setPermissionFunction(function);
+          }
+          return server.getEventManager().fire(new LoginEvent(player))
         .thenAcceptAsync(event -> {
           if (mcConnection.isClosed()) {
             // The player was disconnected
@@ -359,6 +370,7 @@ public class LoginSessionHandler implements MinecraftSessionHandler {
                   return null;
                 });
           }
+        }, mcConnection.eventLoop());
         }, mcConnection.eventLoop())
         .exceptionally((ex) -> {
           logger.error("Exception while completing login initialisation phase for {}", player, ex);
diff --git a/proxy/src/main/java/com/velocitypowered/proxy/connection/client/StatusSessionHandler.java b/proxy/src/main/java/com/velocitypowered/proxy/connection/client/StatusSessionHandler.java
index 792c5b45..b8e0895a 100644
--- a/proxy/src/main/java/com/velocitypowered/proxy/connection/client/StatusSessionHandler.java
+++ b/proxy/src/main/java/com/velocitypowered/proxy/connection/client/StatusSessionHandler.java
@@ -215,6 +215,9 @@ public class StatusSessionHandler implements MinecraftSessionHandler {
               VelocityServer.getPingGsonInstance(connection.getProtocolVersion())
                   .toJson(event.getPing(), json);
               connection.write(new StatusResponse(json));
+              server.getIpAttemptLimiter()
+                  //BotFilter - global rate limiter
+                  .unthrottle(((InetSocketAddress)connection.getRemoteAddress()).getAddress());
             },
             connection.eventLoop())
         .exceptionally((ex) -> {
diff --git a/proxy/src/main/java/com/velocitypowered/proxy/network/ServerChannelInitializer.java b/proxy/src/main/java/com/velocitypowered/proxy/network/ServerChannelInitializer.java
index 55f7d6f8..a0ae648c 100644
--- a/proxy/src/main/java/com/velocitypowered/proxy/network/ServerChannelInitializer.java
+++ b/proxy/src/main/java/com/velocitypowered/proxy/network/ServerChannelInitializer.java
@@ -39,6 +39,8 @@ import io.netty.channel.Channel;
 import io.netty.channel.ChannelInitializer;
 import io.netty.handler.codec.haproxy.HAProxyMessageDecoder;
 import io.netty.handler.timeout.ReadTimeoutHandler;
+
+import java.net.InetSocketAddress;
 import java.util.concurrent.TimeUnit;
 
 @SuppressWarnings("WeakerAccess")
@@ -52,6 +54,16 @@ public class ServerChannelInitializer extends ChannelInitializer<Channel> {
 
   @Override
   protected void initChannel(final Channel ch) {
+
+    //BotFilter start - global rate limiter
+    boolean isProxyProtocol = this.server.getConfiguration().isProxyProtocol();
+    if (!isProxyProtocol && !server.getIpAttemptLimiter()
+        .attempt(((InetSocketAddress)ch.remoteAddress()).getAddress())) {
+      ch.close();
+      return;
+    }
+    //BotFilter end
+
     ch.pipeline()
         .addLast(LEGACY_PING_DECODER, new LegacyPingDecoder())
         .addLast(FRAME_DECODER, new MinecraftVarintFrameDecoder())
@@ -67,7 +79,7 @@ public class ServerChannelInitializer extends ChannelInitializer<Channel> {
     connection.setSessionHandler(new HandshakeSessionHandler(connection, this.server));
     ch.pipeline().addLast(Connections.HANDLER, connection);
 
-    if (this.server.getConfiguration().isProxyProtocol()) {
+    if (isProxyProtocol) { //BotFilter - reuse variable
       ch.pipeline().addFirst(new HAProxyMessageDecoder());
     }
   }
diff --git a/proxy/src/main/java/com/velocitypowered/proxy/protocol/MinecraftPacket.java b/proxy/src/main/java/com/velocitypowered/proxy/protocol/MinecraftPacket.java
index 7115bb8b..7b2184d9 100644
--- a/proxy/src/main/java/com/velocitypowered/proxy/protocol/MinecraftPacket.java
+++ b/proxy/src/main/java/com/velocitypowered/proxy/protocol/MinecraftPacket.java
@@ -19,15 +19,24 @@ package com.velocitypowered.proxy.protocol;
 
 import com.velocitypowered.api.network.ProtocolVersion;
 import com.velocitypowered.proxy.connection.MinecraftSessionHandler;
+import com.velocitypowered.proxy.protocol.ProtocolUtils.Direction;
 import io.netty.buffer.ByteBuf;
 
 public interface MinecraftPacket {
 
-  void decode(ByteBuf buf, ProtocolUtils.Direction direction, ProtocolVersion protocolVersion);
+  //BotFilter start - add default to methods
+  default void decode(ByteBuf buf, Direction direction, ProtocolVersion protocolVersion) {
+    throw new UnsupportedOperationException();
+  }
 
-  void encode(ByteBuf buf, ProtocolUtils.Direction direction, ProtocolVersion protocolVersion);
+  default void encode(ByteBuf buf, Direction direction, ProtocolVersion protocolVersion) {
+    throw new UnsupportedOperationException();
+  }
 
-  boolean handle(MinecraftSessionHandler handler);
+  default boolean handle(MinecraftSessionHandler handler) {
+    throw new UnsupportedOperationException();
+  }
+  //BotFilter end
 
   default int expectedMaxLength(ByteBuf buf, ProtocolUtils.Direction direction,
       ProtocolVersion version) {
diff --git a/proxy/src/main/java/com/velocitypowered/proxy/protocol/StateRegistry.java b/proxy/src/main/java/com/velocitypowered/proxy/protocol/StateRegistry.java
index a65946e0..b50754f8 100644
--- a/proxy/src/main/java/com/velocitypowered/proxy/protocol/StateRegistry.java
+++ b/proxy/src/main/java/com/velocitypowered/proxy/protocol/StateRegistry.java
@@ -297,7 +297,7 @@ public enum StateRegistry {
       clientbound.register(LoginPluginMessage.class, LoginPluginMessage::new,
           map(0x04, MINECRAFT_1_13, false));
     }
-  };
+  }, BotFilter{};
 
   public static final int STATUS_ID = 1;
   public static final int LOGIN_ID = 2;
@@ -323,7 +323,8 @@ public enum StateRegistry {
       this.versions = Collections.unmodifiableMap(mutableVersions);
     }
 
-    ProtocolRegistry getProtocolRegistry(final ProtocolVersion version) {
+    //BotFilter public
+    public ProtocolRegistry getProtocolRegistry(final ProtocolVersion version) {
       ProtocolRegistry registry = versions.get(version);
       if (registry == null) {
         if (fallback) {
@@ -334,7 +335,8 @@ public enum StateRegistry {
       return registry;
     }
 
-    <P extends MinecraftPacket> void register(Class<P> clazz, Supplier<P> packetSupplier,
+    //BotFilter public
+    public <P extends MinecraftPacket> void register(Class<P> clazz, Supplier<P> packetSupplier,
         PacketMapping... mappings) {
       if (mappings.length == 0) {
         throw new IllegalArgumentException("At least one mapping must be provided.");
@@ -436,6 +438,23 @@ public enum StateRegistry {
         }
         return id;
       }
+      /**
+       * Attempts to look up the packet ID for a {@code packet} class.
+       *
+       * @param clazz the packet class to look up
+       * @return the packet ID
+       * @throws IllegalArgumentException if the packet ID is not found
+       */
+      public int getPacketId(final Class<? extends MinecraftPacket> clazz) {
+        final int id = this.packetClassToId.getInt(clazz);
+        if (id == Integer.MIN_VALUE) {
+          throw new IllegalArgumentException(String.format(
+                  "Unable to find id for packet of type %s in %s protocol %s",
+                  clazz.getName(), PacketRegistry.this.direction, this.version
+          ));
+        }
+        return id;
+      }
     }
   }
 
@@ -492,7 +511,8 @@ public enum StateRegistry {
    * @return PacketMapping with the provided arguments
    */
   @SuppressFBWarnings({"UPM_UNCALLED_PRIVATE_METHOD"})
-  private static PacketMapping map(int id, ProtocolVersion version, boolean encodeOnly) {
+  //BotFilter public
+  public static PacketMapping map(int id, ProtocolVersion version, boolean encodeOnly) {
     return map(id, version, null, encodeOnly);
   }
 
@@ -505,7 +525,8 @@ public enum StateRegistry {
    * @param lastValidProtocolVersion Last version this Mapping is valid at
    * @return PacketMapping with the provided arguments
    */
-  private static PacketMapping map(int id, ProtocolVersion version,
+  //BotFilter public
+  public static PacketMapping map(int id, ProtocolVersion version,
           ProtocolVersion lastValidProtocolVersion, boolean encodeOnly) {
     return new PacketMapping(id, version, lastValidProtocolVersion, encodeOnly);
   }
diff --git a/proxy/src/main/java/com/velocitypowered/proxy/util/ratelimit/GuavaCacheRatelimiter.java b/proxy/src/main/java/com/velocitypowered/proxy/util/ratelimit/GuavaCacheRatelimiter.java
index 0c1976be..04a37654 100644
--- a/proxy/src/main/java/com/velocitypowered/proxy/util/ratelimit/GuavaCacheRatelimiter.java
+++ b/proxy/src/main/java/com/velocitypowered/proxy/util/ratelimit/GuavaCacheRatelimiter.java
@@ -22,32 +22,47 @@ import com.google.common.base.Preconditions;
 import com.google.common.base.Ticker;
 import com.google.common.cache.Cache;
 import com.google.common.cache.CacheBuilder;
+import com.google.common.cache.CacheLoader;
+import com.google.common.cache.LoadingCache;
+import org.jetbrains.annotations.NotNull;
+
 import java.net.InetAddress;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
 
 /**
  * A simple rate-limiter based on a Guava {@link Cache}.
  */
 public class GuavaCacheRatelimiter implements Ratelimiter {
 
-  private final Cache<InetAddress, Long> expiringCache;
+  private final LoadingCache<InetAddress, AtomicInteger> cache;
   private final long timeoutNanos;
+  private final int maxAttempts;
+
+  //BotFilter - global rate limiter
+  GuavaCacheRatelimiter(long time, int maxAttempts, TimeUnit unit) {
+    this(time, maxAttempts, unit, Ticker.systemTicker());
 
-  GuavaCacheRatelimiter(long time, TimeUnit unit) {
-    this(time, unit, Ticker.systemTicker());
   }
 
+  //BotFilter - global rate limiter
   @VisibleForTesting
-  GuavaCacheRatelimiter(long time, TimeUnit unit, Ticker ticker) {
+  GuavaCacheRatelimiter(long time, int maxAttempts, TimeUnit unit, Ticker ticker) {
     Preconditions.checkNotNull(unit, "unit");
     Preconditions.checkNotNull(ticker, "ticker");
     this.timeoutNanos = unit.toNanos(time);
-    this.expiringCache = CacheBuilder.newBuilder()
+    this.maxAttempts = maxAttempts;
+    this.cache = CacheBuilder.newBuilder()
         .ticker(ticker)
         .concurrencyLevel(Runtime.getRuntime().availableProcessors())
         .expireAfterWrite(time, unit)
-        .build();
+        .build(new CacheLoader<InetAddress, AtomicInteger>() {
+          @Override
+          public AtomicInteger load(@NotNull InetAddress address) {
+            return new AtomicInteger();
+          }
+        });
   }
 
   /**
@@ -59,14 +74,22 @@ public class GuavaCacheRatelimiter implements Ratelimiter {
   @Override
   public boolean attempt(InetAddress address) {
     Preconditions.checkNotNull(address, "address");
-    long expectedNewValue = System.nanoTime() + timeoutNanos;
-    long last;
-    try {
-      last = expiringCache.get(address, () -> expectedNewValue);
-    } catch (ExecutionException e) {
-      // It should be impossible for this to fail.
-      throw new AssertionError(e);
+    //BotFilter - global rate limiter
+    AtomicInteger counter = cache.getUnchecked(address);
+    int curr = counter.incrementAndGet();
+    if (curr == (maxAttempts + 1)) {
+      cache.put(address, counter); // reset timer
+    }
+    return maxAttempts >= curr;
+  }
+
+  //BotFilter - global rate limiter
+  @Override
+  public void unthrottle(InetAddress address) {
+    Preconditions.checkNotNull(address, "address");
+    AtomicInteger curr = cache.getIfPresent(address);
+    if (curr != null) {
+      curr.decrementAndGet();
     }
-    return expectedNewValue == last;
   }
 }
diff --git a/proxy/src/main/java/com/velocitypowered/proxy/util/ratelimit/NoopCacheRatelimiter.java b/proxy/src/main/java/com/velocitypowered/proxy/util/ratelimit/NoopCacheRatelimiter.java
index caf60286..46fa7155 100644
--- a/proxy/src/main/java/com/velocitypowered/proxy/util/ratelimit/NoopCacheRatelimiter.java
+++ b/proxy/src/main/java/com/velocitypowered/proxy/util/ratelimit/NoopCacheRatelimiter.java
@@ -29,4 +29,9 @@ enum NoopCacheRatelimiter implements Ratelimiter {
   public boolean attempt(InetAddress address) {
     return true;
   }
+
+  //BotFilter - global rate limiter
+  @Override
+  public void unthrottle(InetAddress address) {
+  }
 }
diff --git a/proxy/src/main/java/com/velocitypowered/proxy/util/ratelimit/Ratelimiter.java b/proxy/src/main/java/com/velocitypowered/proxy/util/ratelimit/Ratelimiter.java
index 08837091..677e0b56 100644
--- a/proxy/src/main/java/com/velocitypowered/proxy/util/ratelimit/Ratelimiter.java
+++ b/proxy/src/main/java/com/velocitypowered/proxy/util/ratelimit/Ratelimiter.java
@@ -30,4 +30,6 @@ public interface Ratelimiter {
    * @return true if allowed, false if not
    */
   boolean attempt(InetAddress address);
+
+  void unthrottle(InetAddress address);
 }
diff --git a/proxy/src/main/java/com/velocitypowered/proxy/util/ratelimit/Ratelimiters.java b/proxy/src/main/java/com/velocitypowered/proxy/util/ratelimit/Ratelimiters.java
index b9d7a293..94c81d78 100644
--- a/proxy/src/main/java/com/velocitypowered/proxy/util/ratelimit/Ratelimiters.java
+++ b/proxy/src/main/java/com/velocitypowered/proxy/util/ratelimit/Ratelimiters.java
@@ -24,8 +24,9 @@ public final class Ratelimiters {
     throw new AssertionError();
   }
 
-  public static Ratelimiter createWithMilliseconds(long ms) {
-    return ms <= 0 ? NoopCacheRatelimiter.INSTANCE : new GuavaCacheRatelimiter(ms,
-        TimeUnit.MILLISECONDS);
+  //BotFilter - global rate limiter
+  public static Ratelimiter createWithMilliseconds(long ms, int attempts) {
+    return (ms <= 0 || attempts <= 0) ? NoopCacheRatelimiter.INSTANCE : new GuavaCacheRatelimiter(
+            ms, attempts,TimeUnit.MILLISECONDS);
   }
 }
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/ElytraProxy.java b/proxy/src/main/java/ru/elytrium/elytraproxy/ElytraProxy.java
index 1ada4f66..d9850931 100644
--- a/proxy/src/main/java/ru/elytrium/elytraproxy/ElytraProxy.java
+++ b/proxy/src/main/java/ru/elytrium/elytraproxy/ElytraProxy.java
@@ -17,87 +17,63 @@
 
 package ru.elytrium.elytraproxy;
 
-import com.google.common.collect.ImmutableMap;
-import com.google.common.io.ByteStreams;
-
 import com.velocitypowered.api.command.CommandManager;
 import com.velocitypowered.proxy.VelocityServer;
+import com.velocitypowered.proxy.connection.MinecraftConnection;
+import com.velocitypowered.proxy.connection.client.ConnectedPlayer;
+import com.velocitypowered.proxy.connection.client.LoginSessionHandler;
+import com.velocitypowered.proxy.network.Connections;
 import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+
 import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.nio.file.Paths;
-import java.sql.SQLException;
+import io.netty.channel.ChannelPipeline;
+import lombok.Getter;
 
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
-import org.yaml.snakeyaml.Yaml;
+
+import ru.elytrium.elytraproxy.botfilter.protocol.cache.netty.MultiplePreparedPacketsEncoder;
+import ru.elytrium.elytraproxy.botfilter.protocol.cache.netty.PreparedPacketEncoder;
+import ru.elytrium.elytraproxy.botfilter.server.BotFilterSessionHandler;
+import ru.elytrium.elytraproxy.botfilter.server.VirtualServer;
 import ru.elytrium.elytraproxy.commands.AlertCommand;
 import ru.elytrium.elytraproxy.commands.ElytraProxyCommand;
 import ru.elytrium.elytraproxy.commands.FindCommand;
 import ru.elytrium.elytraproxy.commands.SendCommand;
-import ru.elytrium.elytraproxy.config.BaseConfig;
-import ru.elytrium.elytraproxy.config.database.MysqlConfig;
-import ru.elytrium.elytraproxy.database.Database;
-import ru.elytrium.elytraproxy.database.MySqlDatabase;
+import ru.elytrium.elytraproxy.config.Settings;
 
+@Getter
 @SuppressFBWarnings({"RV_RETURN_VALUE_IGNORED",
         "OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE"}) // temp
 public class ElytraProxy {
-  private static final Logger logger = LogManager.getLogger(ElytraProxy.class);
-  private static final ElytraProxy instance = new ElytraProxy();
-  private BaseConfig config = new BaseConfig();
-  private Database database;
-
-  public ElytraProxy() {
-    logger.info("ElytraProxy beta 0.1");
-  }
-
-  /**
-   * Initializes processes and completes launch of antibot.
-   * –ò–Ω—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç –ø—Ä–æ—Ü–µ—Å—Å—ã –∏ –∑–∞–≤–µ—Ä—à–∞–µ—Ç –∑–∞–ø—É—Å–∫ –∞–Ω—Ç–∏–±–æ—Ç–∞.
-   */
-  public void finishLoad(VelocityServer server) {
-    loadConfig(server);
-    initDatabase(server);
-    registerCommand(server);
-  }
-
-  /**
-   * Loads elytraproxy.yml config file.
-   * –ó–∞–≥—Ä—É–∂–∞–µ—Ç –∫–æ–Ω—Ñ–∏–≥-—Ñ–∞–π–ª elytraproxy.yml.
-   */
-  @SuppressFBWarnings(value = "RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE",
-          justification = "ByteStreams.copy checks for null")
-  public void loadConfig(VelocityServer server) {
-    File configFile = Paths.get("elytraproxy.yml").toFile();
+  private final Logger logger = LogManager.getLogger("ElytraProxy");
+  //private Database database;
 
-    try {
-      if (configFile.createNewFile()) {
-        try (InputStream is = getClass().getResourceAsStream("default-elytraproxy.yml");
-             OutputStream os = new FileOutputStream(configFile)) {
+  // BotFilter start
+  private final Logger bfLogger = LogManager.getLogger("BotFilter");
 
-          ByteStreams.copy(is, os);
-        }
+  private final VelocityServer velocityServer;
+  private final VirtualServer virtualServer;
+  // BotFilter end
 
-        Yaml yaml = new Yaml();
-        config = yaml.load(new FileInputStream(configFile));
-      }
-    } catch (IOException | NullPointerException e) {
-      logger.error(e);
-      logger.error("Unable to read/load/save your elytraproxy.yml. The server will shut down.");
-      logger.error("–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –æ–±—Ä–∞—Ç–∏—Ç—å—Å—è –∫ –∫–æ–Ω—Ñ–∏–≥-—Ñ–∞–π–ª—É elytraproxy.yml. –í—ã–∫–ª—é—á–µ–Ω–∏–µ...");
-      server.shutdown();
-    }
+  public ElytraProxy(VelocityServer velocityServer) {
+    Settings.IMP.reload(new File("ElytraProxy", "config.yml"));
+    logger.info("ElytraProxy beta 0.1");
+    // BotFilter start
+    bfLogger.info("BotFilter 1.0");
+    this.velocityServer = velocityServer;
+    this.virtualServer = new VirtualServer(this);
+    this.virtualServer.reload();
+    // BotFilter end
+    registerCommand(velocityServer);
+    //initDatabase(velocityServer);
   }
 
-  /**
-   * Initializes database, creates missing tables.
-   * –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö, —Å–æ–∑–¥–∞–µ—Ç –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏–µ —Ç–∞–±–ª–∏—Ü—ã.
-   */
+  ///**
+  // * Initializes database, creates missing tables.
+  // * –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö, —Å–æ–∑–¥–∞–µ—Ç –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏–µ —Ç–∞–±–ª–∏—Ü—ã.
+  // */
+  /*
   public void initDatabase(VelocityServer server) {
     try {
       MysqlConfig config = getConfig().getMySql();
@@ -110,11 +86,11 @@ public class ElytraProxy {
       ));
     } catch (SQLException e) {
       logger.error(e);
-      logger.error(getConfig().getMessages().error.mysqlLoadFailed);
+      logger.error("–±–æ–ª—å–Ω–æ" getConfig().getMessages().error.mysqlLoadFailed );
       server.shutdown();
     }
   }
-
+  */
   /**
    * Initializes ElytraProxy commands.
    * –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç –∫–æ–º–∞–Ω–¥—ã ElytraProxy.
@@ -128,20 +104,44 @@ public class ElytraProxy {
     manager.unregister("send");
 
     manager.register("elytraproxy", new ElytraProxyCommand(server, this));
-    manager.register("alert", new AlertCommand(server, config.getPrefix()));
-    manager.register("find", new FindCommand(server, config.getPrefix()));
-    manager.register("send", new SendCommand(server, config.getPrefix()));
+    manager.register("alert", new AlertCommand(server, Settings.IMP.MESSAGES.PREFIX));
+    manager.register("find", new FindCommand(server, Settings.IMP.MESSAGES.PREFIX));
+    manager.register("send", new SendCommand(server, Settings.IMP.MESSAGES.PREFIX));
   }
 
-  public static ElytraProxy getInstance() {
-    return instance;
+  public boolean shouldCheck(ConnectedPlayer player) {
+    return true;
   }
 
-  public BaseConfig getConfig() {
-    return config;
+  public void setupPipelineAndStartCheck(ConnectedPlayer player, LoginSessionHandler handler) {
+    try {
+      BotFilterSessionHandler sessionHandler = new BotFilterSessionHandler(player, handler,
+          virtualServer);
+      bfLogger.info(sessionHandler.getPlayer().getUsername());
+
+      MinecraftConnection connection = sessionHandler.getPlayer().getConnection();
+      connection.setSessionHandler(sessionHandler);
+
+      ChannelPipeline pipeline = connection.getChannel().pipeline();
+
+      if (sessionHandler.getPlayer().isOnlineMode()) {
+        pipeline.addAfter(Connections.CIPHER_ENCODER, "prepared-encoder",
+            PreparedPacketEncoder.getEncoder(connection.getProtocolVersion(), true));
+      } else {
+        pipeline.addFirst("prepared-encoder",
+            PreparedPacketEncoder.getEncoder(connection.getProtocolVersion(), false));
+        pipeline.addFirst("multipleprepared-encoder",
+            MultiplePreparedPacketsEncoder.getEncoder(connection.getProtocolVersion()));
+      }
+
+      virtualServer.spawnPlayer(sessionHandler);
+    } catch (Throwable t) {
+      bfLogger.error("Error", t);
+    }
   }
 
-  public Database getDatabase() {
-    return database;
+  public void reload() {
+    logger.info("Reloading...");
+    new ElytraProxy(velocityServer);
   }
 }
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/BotFilterProtocol.java b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/BotFilterProtocol.java
new file mode 100644
index 00000000..ccd3864f
--- /dev/null
+++ b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/BotFilterProtocol.java
@@ -0,0 +1,81 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.elytrium.elytraproxy.botfilter.protocol;
+
+import static com.velocitypowered.api.network.ProtocolVersion.MINECRAFT_1_13;
+import static com.velocitypowered.api.network.ProtocolVersion.MINECRAFT_1_14;
+import static com.velocitypowered.api.network.ProtocolVersion.MINECRAFT_1_15;
+import static com.velocitypowered.api.network.ProtocolVersion.MINECRAFT_1_16;
+import static com.velocitypowered.api.network.ProtocolVersion.MINECRAFT_1_16_2;
+import static com.velocitypowered.api.network.ProtocolVersion.MINECRAFT_1_7_2;
+import static com.velocitypowered.api.network.ProtocolVersion.MINECRAFT_1_9;
+import static com.velocitypowered.proxy.protocol.StateRegistry.map;
+
+import com.velocitypowered.api.network.ProtocolVersion;
+import com.velocitypowered.proxy.protocol.StateRegistry;
+import ru.elytrium.elytraproxy.botfilter.protocol.packet.JoinGame;
+import ru.elytrium.elytraproxy.botfilter.protocol.packet.PlayerPositionAndLook;
+import ru.elytrium.elytraproxy.botfilter.protocol.packet.world.ChunkData;
+import ru.elytrium.elytraproxy.botfilter.protocol.packet.world.UpdateLight;
+
+public class BotFilterProtocol {
+
+  public static void init() {
+    StateRegistry.BotFilter.clientbound.register(
+        JoinGame.class, JoinGame::new,
+        map(0x01, MINECRAFT_1_7_2, false),
+        map(0x23, MINECRAFT_1_9, false),
+        map(0x25, MINECRAFT_1_13, false),
+        map(0x25, MINECRAFT_1_14, false),
+        map(0x26, MINECRAFT_1_15, false),
+        map(0x25, MINECRAFT_1_16, false),
+        map(0x24, MINECRAFT_1_16_2, false)
+    );
+    StateRegistry.BotFilter.clientbound.register(
+        PlayerPositionAndLook.class, PlayerPositionAndLook::new,
+        map(0x08, ProtocolVersion.MINECRAFT_1_7_2, true),
+        map(0x2E, ProtocolVersion.MINECRAFT_1_9, true),
+        map(0x2F, ProtocolVersion.MINECRAFT_1_12_1, true),
+        map(0x32, ProtocolVersion.MINECRAFT_1_13, true),
+        map(0x35, ProtocolVersion.MINECRAFT_1_14, true),
+        map(0x36, ProtocolVersion.MINECRAFT_1_15, true),
+        map(0x35, ProtocolVersion.MINECRAFT_1_16, true),
+        map(0x34, ProtocolVersion.MINECRAFT_1_16_2, true));
+
+    StateRegistry.BotFilter.clientbound.register(
+        ChunkData.class, ChunkData::new,
+        map(0x21, ProtocolVersion.MINECRAFT_1_7_2, true),
+        map(0x21, ProtocolVersion.MINECRAFT_1_8, true),
+        map(0x20, ProtocolVersion.MINECRAFT_1_9, true),
+        map(0x22, ProtocolVersion.MINECRAFT_1_13, true),
+        map(0x21, ProtocolVersion.MINECRAFT_1_14, true),
+        map(0x22, ProtocolVersion.MINECRAFT_1_15, true),
+        map(0x21, ProtocolVersion.MINECRAFT_1_16, true),
+        map(0x20, ProtocolVersion.MINECRAFT_1_16_2, true));
+
+    StateRegistry.BotFilter.clientbound.register(
+        UpdateLight.class, UpdateLight::new,
+        map(0x24, ProtocolVersion.MINECRAFT_1_14, true),
+        map(0x25, ProtocolVersion.MINECRAFT_1_15, true),
+        map(0xF0, ProtocolVersion.MINECRAFT_1_16, true)); //RANDOM ID
+
+
+  }
+
+}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/cache/ByteBufCreator.java b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/cache/ByteBufCreator.java
new file mode 100644
index 00000000..9de49411
--- /dev/null
+++ b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/cache/ByteBufCreator.java
@@ -0,0 +1,52 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.elytrium.elytraproxy.botfilter.protocol.cache;
+
+import com.velocitypowered.natives.compression.VelocityCompressor;
+import com.velocitypowered.natives.util.BufferPreference;
+import com.velocitypowered.natives.util.Natives;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+
+public class ByteBufCreator {
+
+  private static boolean directBuffers = false;
+
+  static {
+    VelocityCompressor compressor = Natives.compress.get().create(1);
+    if (compressor.preferredBufferType() == BufferPreference.DIRECT_PREFERRED
+        || compressor.preferredBufferType() == BufferPreference.DIRECT_REQUIRED) {
+      directBuffers = true;
+    }
+    compressor.close();
+  }
+
+
+  public static ByteBuf newBuffer() {
+    return directBuffers ? Unpooled.directBuffer() : Unpooled.buffer();
+  }
+
+  public static ByteBuf newBuffer(int length) {
+    return directBuffers ? Unpooled.directBuffer(length) : Unpooled.buffer(length);
+  }
+
+  public static boolean isDirectBufferPreferred() {
+    return directBuffers;
+  }
+}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/cache/MultiplePreparedPackets.java b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/cache/MultiplePreparedPackets.java
new file mode 100644
index 00000000..fe5d0c11
--- /dev/null
+++ b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/cache/MultiplePreparedPackets.java
@@ -0,0 +1,99 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.elytrium.elytraproxy.botfilter.protocol.cache;
+
+import com.google.common.base.Preconditions;
+import com.velocitypowered.api.network.ProtocolVersion;
+import com.velocitypowered.proxy.connection.MinecraftConnection;
+import io.netty.buffer.ByteBuf;
+import java.util.EnumMap;
+import java.util.EnumSet;
+import java.util.HashSet;
+import java.util.Map;
+
+public class MultiplePreparedPackets {
+
+  private Map<ProtocolVersion, ByteBuf> multiplePayloadBuf = new EnumMap<ProtocolVersion, ByteBuf>(
+      ProtocolVersion.class);
+  private PreparedPacket[] onlineModePackets;
+
+  public MultiplePreparedPackets(PreparedPacket... preparedPackets) {
+    for (PreparedPacket packet : preparedPackets) {
+      Preconditions.checkState(packet.isFinished(), "PreparedPacket is not adapted");
+    }
+    onlineModePackets = preparedPackets;
+    createOfflineModePayload(preparedPackets);
+  }
+
+  private void createOfflineModePayload(PreparedPacket... preparedPackets) {
+    for (ProtocolVersion protocolVersion : EnumSet
+        .range(ProtocolVersion.MINIMUM_VERSION, ProtocolVersion.MAXIMUM_VERSION)) {
+      ByteBuf multiple = ByteBufCreator.newBuffer();
+      for (PreparedPacket preparedPacket : preparedPackets) {
+        ByteBuf buf = preparedPacket.getBuffer(protocolVersion);
+        if (buf == null) {
+          continue;
+        }
+        multiple.writeBytes(buf);
+        buf.release();
+      }
+
+      if (multiple.readableBytes() == 0) {
+        multiple.release();
+        continue;
+      }
+      //Deduplicate
+      for (ByteBuf byteBuf : multiplePayloadBuf.values()) {
+        if (byteBuf.equals(multiple)) {
+          multiple.release();
+          multiple = byteBuf;
+          break;
+        }
+      }
+      multiplePayloadBuf.put(protocolVersion, multiple);
+    }
+  }
+
+  public void write(MinecraftConnection connection, boolean onlineMode) {
+    if (onlineMode) {
+      for (PreparedPacket preparedPacket : onlineModePackets) {
+        preparedPacket.selfWrite(connection, false);
+      }
+    } else {
+      connection.delayedWrite(this);
+    }
+  }
+
+  public ByteBuf getBuffer(ProtocolVersion protocolVersion) {
+    return multiplePayloadBuf.get(protocolVersion).retainedSlice();
+  }
+
+  public int getBuffetLength(ProtocolVersion protocolVersion) {
+    return multiplePayloadBuf.get(protocolVersion).readableBytes();
+  }
+
+  public void release() {
+    for (PreparedPacket preparedPacket : onlineModePackets) {
+      preparedPacket.releaseBuffers();
+    }
+    for (ByteBuf byteBuf : new HashSet<>(multiplePayloadBuf.values())) {
+      byteBuf.release();
+    }
+  }
+}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/cache/PacketCompressor.java b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/cache/PacketCompressor.java
new file mode 100644
index 00000000..3a97f958
--- /dev/null
+++ b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/cache/PacketCompressor.java
@@ -0,0 +1,69 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.elytrium.elytraproxy.botfilter.protocol.cache;
+
+import com.velocitypowered.natives.compression.VelocityCompressor;
+import com.velocitypowered.natives.util.Natives;
+import com.velocitypowered.proxy.config.VelocityConfiguration;
+import com.velocitypowered.proxy.protocol.ProtocolUtils;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import java.util.function.Supplier;
+
+public class PacketCompressor {
+
+  private final ThreadLocal<VelocityCompressor> compressors = ThreadLocal
+      .withInitial(() -> Natives.compress.get().create(12));
+  private final Supplier<VelocityConfiguration> velocityConfiguration;
+
+  /**
+   * Constructs VelocityPacketCompressor.
+   *
+   * @param velocityConfiguration configuration
+   */
+  public PacketCompressor(Supplier<VelocityConfiguration> velocityConfiguration) {
+    this.velocityConfiguration = velocityConfiguration;
+
+  }
+
+  public boolean isCompressionEnabled() {
+    return velocityConfiguration.get().getCompressionThreshold() >= 0;
+  }
+
+  public boolean shouldCompress(int i) {
+    return isCompressionEnabled() && i >= velocityConfiguration.get().getCompressionThreshold();
+  }
+
+  public ByteBuf compress(ByteBuf source) {
+    VelocityCompressor compressor = compressors.get();
+    ByteBuf destination =
+        ByteBufCreator.isDirectBufferPreferred() ? Unpooled.directBuffer() : Unpooled.buffer();
+    int uncompressed = source.readableBytes();
+    ProtocolUtils.writeVarInt(destination, uncompressed);
+    try {
+      compressor.deflate(source, destination);
+    } catch (Exception e) {
+      throw new RuntimeException(e);
+    } finally {
+      source.release();
+    }
+    return destination;
+  }
+
+}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/cache/PreparedPacket.java b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/cache/PreparedPacket.java
new file mode 100644
index 00000000..d2abd664
--- /dev/null
+++ b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/cache/PreparedPacket.java
@@ -0,0 +1,217 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.elytrium.elytraproxy.botfilter.protocol.cache;
+
+import com.velocitypowered.api.network.ProtocolVersion;
+import com.velocitypowered.proxy.connection.MinecraftConnection;
+import com.velocitypowered.proxy.protocol.MinecraftPacket;
+import com.velocitypowered.proxy.protocol.ProtocolUtils;
+import com.velocitypowered.proxy.protocol.ProtocolUtils.Direction;
+import com.velocitypowered.proxy.protocol.StateRegistry;
+import io.netty.buffer.ByteBuf;
+import io.netty.util.ReferenceCountUtil;
+import java.util.EnumMap;
+import java.util.EnumSet;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Map.Entry;
+import ru.elytrium.elytraproxy.botfilter.protocol.BotFilterProtocol;
+
+
+public class PreparedPacket<T extends MinecraftPacket> {
+
+  static {
+    BotFilterProtocol.init();
+  }
+
+  private final Map<ProtocolVersion, ByteBufHolder> offlineMode =
+      new EnumMap<>(ProtocolVersion.class);
+  private boolean finished = false;
+
+  public PreparedPacket() {
+  }
+
+  public void prepareSinge(T packet, ProtocolVersion version) {
+    prepare(packet, version, version);
+  }
+
+  public void prepareSinge(T packet, ProtocolVersion version, StateRegistry protocol) {
+    prepare(packet, version, version, protocol);
+  }
+
+  public void prepare(T packet) {
+    prepare(packet, ProtocolVersion.MINIMUM_VERSION, ProtocolVersion.MAXIMUM_VERSION);
+  }
+
+  public void prepare(T packet, ProtocolVersion from) {
+    prepare(packet, from, ProtocolVersion.MAXIMUM_VERSION);
+  }
+
+  public void prepare(T packet, ProtocolVersion from, ProtocolVersion to) {
+    prepare(packet, from, to, StateRegistry.BotFilter);
+  }
+
+  public void prepare(T packet, ProtocolVersion from, ProtocolVersion to, StateRegistry protocol) {
+    for (ProtocolVersion protocolVersion : EnumSet.range(from, to)) {
+      ByteBuf buf = encodePacket(packet, protocolVersion, protocol);
+      ByteBufHolder holder = getHolder(buf, protocolVersion);
+      offlineMode.put(protocolVersion, holder);
+    }
+  }
+
+  /*
+  public void preparePacketAndCopy(T packet, ProtocolVersion start, ProtocolVersion end,
+      StateRegistry protocol) {
+    ByteBuf buf = encodePacket(packet, start, protocol);
+    ByteBufHolder holder = new ByteBufHolder(start.isBefore(ProtocolVersion.MINECRAFT_1_8), buf);
+    for (ProtocolVersion protocolVersion : EnumSet.range(start, end)) {
+      prepared.put(protocolVersion, holder);
+    }
+  }
+
+   */
+
+  private ByteBuf encodePacket(T packet, ProtocolVersion version, StateRegistry protocol) {
+    int id = getPacketId(packet, version, protocol);
+    ByteBuf byteBuf = ByteBufCreator.newBuffer();
+    ProtocolUtils.writeVarInt(byteBuf, id);
+    packet.encode(byteBuf, Direction.CLIENTBOUND, version);
+    return byteBuf;
+  }
+
+  private int getPacketId(T packet, ProtocolVersion version, StateRegistry protocol) {
+    try {
+      return protocol.clientbound.getProtocolRegistry(version).getPacketId(packet.getClass());
+    } catch (Exception e) {
+      return protocol.clientbound.getProtocolRegistry(version).getPacketId(
+          (Class<? extends MinecraftPacket>) packet.getClass().getSuperclass());
+    }
+  }
+
+  public ByteBuf getBuffer(ProtocolVersion version) {
+    ByteBufHolder holder = offlineMode.get(version);
+    return holder == null ? null : holder.byteBuf.retainedSlice();
+  }
+
+
+  public int getBufferLength(ProtocolVersion version) {
+    ByteBufHolder holder = offlineMode.get(version);
+    return holder == null ? 0 : holder.byteBuf.readableBytes();
+  }
+
+  public void selfWrite(MinecraftConnection mc, boolean flush) {
+    if (offlineMode.containsKey(mc.getProtocolVersion())) {
+      if (flush) {
+        mc.write(this);
+      } else {
+        mc.delayedWrite(this);
+      }
+    }
+  }
+
+  public boolean isFinished() {
+    return finished;
+  }
+
+
+  private ByteBufHolder getHolder(ByteBuf buf, ProtocolVersion version) {
+    if (version.isBefore(ProtocolVersion.MINECRAFT_1_8)) {
+      ByteBufHolder holder = offlineMode.get(ProtocolVersion.MINECRAFT_1_7_2);
+      if (holder != null && holder.byteBuf.equals(buf)) {
+        buf.release();
+        return holder;
+      }
+      return new ByteBufHolder(true, buf);
+    }
+
+    for (ByteBufHolder holder : new HashSet<>(offlineMode.values())) {
+      if (!holder.mc1_7 && holder.byteBuf.equals(buf)) {
+        buf.release();
+        return holder;
+      }
+    }
+    return new ByteBufHolder(false, buf);
+  }
+
+
+  public void processCompress(PacketCompressor packetCompressor) {
+    if (finished) {
+      throw new IllegalStateException("Packet compression does not allowed after adapt");
+    }
+    for (Entry<ProtocolVersion, ByteBufHolder> prepared : offlineMode.entrySet()) {
+      ByteBufHolder holder = prepared.getValue();
+      if (holder.mc1_7 || holder.compressed) {
+        continue;
+      }
+      ByteBuf current = holder.byteBuf;
+      ByteBuf newBuf;
+      int bytes = current.readableBytes();
+      holder.compressed = true;
+      if (packetCompressor.shouldCompress(bytes)) {
+        newBuf = packetCompressor.compress(current);
+      } else {
+        newBuf = ByteBufCreator.newBuffer(2 + current.readableBytes());
+        ProtocolUtils.writeVarInt(newBuf, 0);
+        newBuf.writeBytes(current);
+      }
+      newBuf.capacity(newBuf.readableBytes());
+      holder.byteBuf = newBuf;
+    }
+  }
+
+  public void finish() {
+    for (Entry<ProtocolVersion, ByteBufHolder> prepared : offlineMode.entrySet()) {
+      ByteBufHolder holder = prepared.getValue();
+      if (holder.varint) {
+        continue;
+      }
+      ByteBuf current = holder.byteBuf;
+      ByteBuf buf = ByteBufCreator.newBuffer(5 + current.readableBytes());
+      ProtocolUtils.writeVarInt(buf, current.readableBytes());
+      buf.writeBytes(current);
+      buf.capacity(buf.readableBytes());
+      ReferenceCountUtil.safeRelease(current);
+      holder.byteBuf = buf;
+      holder.varint = true;
+    }
+    finished = true;
+  }
+
+  public void releaseBuffers() {
+    for (ByteBufHolder holder : new HashSet<>(offlineMode.values())) {
+      holder.byteBuf.release();
+    }
+  }
+
+  private static class ByteBufHolder {
+
+    private final boolean mc1_7;
+    private ByteBuf byteBuf;
+    private boolean compressed = false;
+    private boolean varint = false;
+
+    public ByteBufHolder(boolean mc1_7, ByteBuf byteBuf) {
+      this.mc1_7 = mc1_7;
+      this.byteBuf = byteBuf;
+      if (mc1_7) {
+        compressed = true;
+      }
+    }
+  }
+}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/cache/netty/MultiplePreparedPacketsEncoder.java b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/cache/netty/MultiplePreparedPacketsEncoder.java
new file mode 100644
index 00000000..c89231fd
--- /dev/null
+++ b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/cache/netty/MultiplePreparedPacketsEncoder.java
@@ -0,0 +1,72 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.elytrium.elytraproxy.botfilter.protocol.cache.netty;
+
+import com.velocitypowered.api.network.ProtocolVersion;
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandler.Sharable;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.MessageToMessageEncoder;
+import java.util.EnumMap;
+import java.util.List;
+import java.util.Map;
+import lombok.RequiredArgsConstructor;
+import ru.elytrium.elytraproxy.botfilter.protocol.cache.MultiplePreparedPackets;
+
+@Sharable
+@RequiredArgsConstructor
+public class MultiplePreparedPacketsEncoder extends
+    MessageToMessageEncoder<MultiplePreparedPackets> {
+
+
+  private static Map<ProtocolVersion, MultiplePreparedPacketsEncoder> encoders = new EnumMap<>(
+      ProtocolVersion.class);
+
+  static {
+    for (ProtocolVersion version : ProtocolVersion.SUPPORTED_VERSIONS) {
+      encoders.put(version, new MultiplePreparedPacketsEncoder(version));
+    }
+  }
+
+  private final ProtocolVersion protocolVersion;
+
+
+  @Override
+  protected void encode(ChannelHandlerContext ctx, MultiplePreparedPackets msg, List<Object> out)
+      throws Exception {
+    ByteBuf buf = msg.getBuffer(protocolVersion);
+    out.add(buf);
+  }
+
+  /*
+  @Override
+  protected ByteBuf allocateBuffer(ChannelHandlerContext ctx, MultiplePreparedPackets msg,
+      boolean preferDirect) throws Exception {
+    int length = msg.getBuffetLength(protocolVersion);
+    return ByteBufCreator.isDirectBufferPreferred() ? ctx.alloc().directBuffer(length)
+        : ctx.alloc().heapBuffer(length);
+  }
+
+   */
+
+
+  public static MultiplePreparedPacketsEncoder getEncoder(ProtocolVersion version) {
+    return encoders.get(version);
+  }
+}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/cache/netty/PreparedPacketEncoder.java b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/cache/netty/PreparedPacketEncoder.java
new file mode 100644
index 00000000..5299d34f
--- /dev/null
+++ b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/cache/netty/PreparedPacketEncoder.java
@@ -0,0 +1,78 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.elytrium.elytraproxy.botfilter.protocol.cache.netty;
+
+import com.google.common.collect.HashBasedTable;
+import com.google.common.collect.Table;
+import com.velocitypowered.api.network.ProtocolVersion;
+import com.velocitypowered.natives.encryption.JavaVelocityCipher;
+import com.velocitypowered.natives.util.Natives;
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandler.Sharable;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.MessageToMessageEncoder;
+import java.util.List;
+import lombok.RequiredArgsConstructor;
+import ru.elytrium.elytraproxy.botfilter.protocol.cache.PreparedPacket;
+
+@Sharable
+@RequiredArgsConstructor
+public class PreparedPacketEncoder extends MessageToMessageEncoder<PreparedPacket> {
+
+
+  private static final boolean IS_JAVA_CIPHER = Natives.cipher.get() == JavaVelocityCipher.FACTORY;
+  private static Table<ProtocolVersion, Boolean, PreparedPacketEncoder> encoders = HashBasedTable
+      .create(ProtocolVersion.SUPPORTED_VERSIONS.size(), 2);
+
+
+  static {
+    for (ProtocolVersion version : ProtocolVersion.SUPPORTED_VERSIONS) {
+      encoders.put(version, true, new PreparedPacketEncoder(version, true));
+      encoders.put(version, false, new PreparedPacketEncoder(version, false));
+    }
+  }
+
+  private final ProtocolVersion protocolVersion;
+  private final boolean onlineMode;
+
+
+  @Override
+  protected void encode(ChannelHandlerContext ctx, PreparedPacket msg, List<Object> out)
+      throws Exception {
+    ByteBuf buf = msg.getBuffer(protocolVersion);
+    out.add(buf);
+  }
+
+  /*
+
+  @Override
+  protected ByteBuf allocateBuffer(ChannelHandlerContext ctx, PreparedPacket msg,
+      boolean preferDirect) throws Exception {
+    int length = msg.getBufferLength(protocolVersion);
+    boolean direct = onlineMode ? IS_JAVA_CIPHER : ByteBufCreator.isDirectBufferPreferred();
+    return direct ? ctx.alloc().directBuffer(length) : ctx.alloc().heapBuffer(length);
+  }
+
+   */
+
+
+  public static PreparedPacketEncoder getEncoder(ProtocolVersion version, boolean onlineMode) {
+    return encoders.get(version, onlineMode);
+  }
+}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/packet/JoinGame.java b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/packet/JoinGame.java
new file mode 100644
index 00000000..2d2dac2b
--- /dev/null
+++ b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/packet/JoinGame.java
@@ -0,0 +1,114 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.elytrium.elytraproxy.botfilter.protocol.packet;
+
+import com.velocitypowered.api.network.ProtocolVersion;
+import com.velocitypowered.proxy.connection.registry.DimensionInfo;
+import com.velocitypowered.proxy.protocol.MinecraftPacket;
+import com.velocitypowered.proxy.protocol.ProtocolUtils;
+import io.netty.buffer.ByteBuf;
+import lombok.AllArgsConstructor;
+import lombok.Builder;
+import lombok.Getter;
+import lombok.NoArgsConstructor;
+import lombok.Setter;
+import lombok.ToString;
+import ru.elytrium.elytraproxy.botfilter.protocol.registry.DimensionRegistry;
+
+
+@Getter
+@Setter
+@AllArgsConstructor
+@NoArgsConstructor
+@ToString
+@Builder
+public class JoinGame implements MinecraftPacket {
+
+  private int entityId;
+  private short gamemode;
+  private int dimension;
+  private long partialHashedSeed;
+  private short difficulty;
+  private boolean hardcore;
+  private int maxPlayers;
+  private String levelType;
+  private int viewDistance;
+  private boolean reducedDebugInfo;
+  private boolean showRespawnScreen;
+  private DimensionRegistry dimensionRegistry;
+  private short previousGamemode;
+
+
+  @Override
+  public void encode(ByteBuf buf, ProtocolUtils.Direction direction, ProtocolVersion version) {
+    buf.writeInt(entityId);
+    if (version.isAfterOrEq(ProtocolVersion.MINECRAFT_1_16_2)) {
+      buf.writeBoolean(hardcore);
+      buf.writeByte(gamemode);
+    } else {
+      buf.writeByte(hardcore ? gamemode | 0x8 : gamemode);
+    }
+    DimensionInfo dimensionInfo = dimensionRegistry.getActiveDimensionInfo();
+    if (version.isAfterOrEq(ProtocolVersion.MINECRAFT_1_16)) {
+      buf.writeByte(previousGamemode);
+      ProtocolUtils.writeStringArray(buf,
+          dimensionRegistry.getWorldNames().toArray(new String[0])); //worldNames
+      ProtocolUtils.writeCompoundTag(buf, dimensionRegistry.encode(version));
+      if (version.isAfterOrEq(ProtocolVersion.MINECRAFT_1_16_2)) {
+        ProtocolUtils.writeCompoundTag(buf,
+            dimensionRegistry.getActiveDimension().encodeAttributes(version));
+        ProtocolUtils.writeString(buf, dimensionInfo.getRegistryIdentifier());
+      } else {
+        ProtocolUtils.writeString(buf, dimensionInfo.getRegistryIdentifier());
+        ProtocolUtils.writeString(buf, dimensionInfo.getLevelName());
+      }
+    } else if (version.isAfterOrEq(ProtocolVersion.MINECRAFT_1_9_1)) {
+      buf.writeInt(dimension);
+    } else {
+      buf.writeByte(dimension);
+    }
+    if (version.isBeforeOrEq(ProtocolVersion.MINECRAFT_1_13_2)) {
+      buf.writeByte(difficulty);
+    }
+    if (version.isAfterOrEq(ProtocolVersion.MINECRAFT_1_15)) {
+      buf.writeLong(partialHashedSeed);
+    }
+    if (version.isAfterOrEq(ProtocolVersion.MINECRAFT_1_16_2)) {
+      ProtocolUtils.writeVarInt(buf, maxPlayers);
+    } else {
+      buf.writeByte(maxPlayers);
+    }
+    if (version.isBefore(ProtocolVersion.MINECRAFT_1_16)) {
+      ProtocolUtils.writeString(buf, levelType);
+    }
+    if (version.isAfterOrEq(ProtocolVersion.MINECRAFT_1_14)) {
+      ProtocolUtils.writeVarInt(buf, viewDistance);
+    }
+    if (version.isAfterOrEq(ProtocolVersion.MINECRAFT_1_8)) {
+      buf.writeBoolean(reducedDebugInfo);
+    }
+    if (version.isAfterOrEq(ProtocolVersion.MINECRAFT_1_15)) {
+      buf.writeBoolean(showRespawnScreen);
+    }
+    if (version.isAfterOrEq(ProtocolVersion.MINECRAFT_1_16)) {
+      buf.writeBoolean(dimensionInfo.isDebugType());
+      buf.writeBoolean(dimensionInfo.isFlat());
+    }
+  }
+}
\ No newline at end of file
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/packet/PlayerPositionAndLook.java b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/packet/PlayerPositionAndLook.java
new file mode 100644
index 00000000..5c11ad14
--- /dev/null
+++ b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/packet/PlayerPositionAndLook.java
@@ -0,0 +1,84 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.elytrium.elytraproxy.botfilter.protocol.packet;
+
+import com.velocitypowered.api.network.ProtocolVersion;
+import com.velocitypowered.proxy.connection.MinecraftSessionHandler;
+import com.velocitypowered.proxy.protocol.MinecraftPacket;
+import com.velocitypowered.proxy.protocol.ProtocolUtils;
+import com.velocitypowered.proxy.protocol.ProtocolUtils.Direction;
+import io.netty.buffer.ByteBuf;
+import lombok.AllArgsConstructor;
+import lombok.Getter;
+import lombok.NoArgsConstructor;
+import lombok.Setter;
+import lombok.ToString;
+
+@Getter
+@Setter
+@AllArgsConstructor
+@NoArgsConstructor
+@ToString
+public class PlayerPositionAndLook implements MinecraftPacket {
+
+  private double x;
+  private double y;
+  private double z;
+  private float yaw;
+  private float pitch;
+  private int teleportId;
+  private boolean onGround;
+
+
+  @Override
+  public void encode(ByteBuf buf, Direction direction, ProtocolVersion protocolVersion) {
+    buf.writeDouble(this.x);
+    buf.writeDouble(this.y);
+    buf.writeDouble(this.z);
+    buf.writeFloat(this.yaw);
+    buf.writeFloat(this.pitch);
+    if (protocolVersion.isAfterOrEq(ProtocolVersion.MINECRAFT_1_8)) {
+      buf.writeByte(0x00);
+    }
+    if (protocolVersion.isAfterOrEq(ProtocolVersion.MINECRAFT_1_9)) {
+      ProtocolUtils.writeVarInt(buf, teleportId);
+    }
+    if (protocolVersion.isBefore(ProtocolVersion.MINECRAFT_1_8)) {
+      buf.writeBoolean(onGround);
+    }
+  }
+
+  @Override
+  public void decode(ByteBuf buf, Direction direction, ProtocolVersion protocolVersion) {
+    this.x = buf.readDouble();
+    this.y = buf.readDouble();
+    if (protocolVersion.isBefore(ProtocolVersion.MINECRAFT_1_8)) {
+      buf.readDouble(); //Skip HeadY
+    }
+    this.z = buf.readDouble();
+    this.yaw = buf.readFloat();
+    this.pitch = buf.readFloat();
+    this.onGround = buf.readBoolean();
+  }
+
+  @Override
+  public boolean handle(MinecraftSessionHandler handler) {
+    return handler.handle(this);
+  }
+}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/packet/world/Chunk17to115.java b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/packet/world/Chunk17to115.java
new file mode 100644
index 00000000..254a6f33
--- /dev/null
+++ b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/packet/world/Chunk17to115.java
@@ -0,0 +1,215 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.elytrium.elytraproxy.botfilter.protocol.packet.world;
+
+import com.velocitypowered.api.network.ProtocolVersion;
+import com.velocitypowered.proxy.protocol.ProtocolUtils;
+import com.velocitypowered.proxy.protocol.ProtocolUtils.Direction;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.zip.Deflater;
+import net.kyori.adventure.nbt.CompoundBinaryTag;
+import ru.elytrium.elytraproxy.botfilter.protocol.util.NetworkSection;
+import ru.elytrium.elytraproxy.botfilter.protocol.util.mcprotocollib.FlexibleStorage;
+import ru.elytrium.elytraproxy.botfilter.server.world.SimpleBlock;
+import ru.elytrium.elytraproxy.botfilter.server.world.SimpleChunk;
+import ru.elytrium.elytraproxy.botfilter.server.world.SimpleChunk.ChunkSection;
+
+/**
+ * 1.7 - 1.15.2
+ */
+public class Chunk17to115 extends ChunkData {
+
+  private final SimpleChunk simpleChunk;
+  private final List<NetworkSection> networkSections = new ArrayList<>(16);
+
+  public Chunk17to115(SimpleChunk simpleChunk) {
+    super(simpleChunk.getX(), simpleChunk.getZ());
+    this.simpleChunk = simpleChunk;
+  }
+
+  @Override
+  public void encode(ByteBuf buf, Direction direction, ProtocolVersion version) {
+
+    //write data to out buffer
+    buf.writeInt(getX());
+    buf.writeInt(getZ());
+    buf.writeBoolean(true); //Full chunk
+
+    ByteBuf data = Unpooled.buffer(getInitialDataSize(version));
+    int mask = writeChunkData(data, version);
+
+    if (version.isAfterOrEq(ProtocolVersion.MINECRAFT_1_9)) {
+      buf.ensureWritable(1024 * 4 + ((36 * 8) * 2) + 150);
+      ProtocolUtils.writeVarInt(buf, mask);
+
+      if (version.isAfterOrEq(ProtocolVersion.MINECRAFT_1_14)) {
+        ProtocolUtils.writeCompoundTag(buf, buildHeightMap());
+      }
+      if (version.isAfterOrEq(ProtocolVersion.MINECRAFT_1_15)) {
+        writeChunkBiomes(buf, version);
+      }
+      buf.ensureWritable(data.readableBytes() + 5 + 1);
+      ProtocolUtils.writeVarInt(buf, data.readableBytes());
+      buf.writeBytes(data);
+      if (version.isAfterOrEq(ProtocolVersion.MINECRAFT_1_9_4)) {
+        ProtocolUtils.writeVarInt(buf, 0); // no tile entities nbts
+      }
+    } else {
+      buf.writeShort(mask); //Number of chunks
+      if (version.isBefore(ProtocolVersion.MINECRAFT_1_8)) {
+        write17(buf, data);
+      } else {
+        ProtocolUtils.writeVarInt(buf, data.readableBytes());
+        buf.writeBytes(data);
+      }
+    }
+    data.release();
+
+  }
+
+  private CompoundBinaryTag buildHeightMap() {
+    FlexibleStorage surface = new FlexibleStorage(9, 256);
+    FlexibleStorage motionBlocking = new FlexibleStorage(9, 256);
+
+    for (int y = 0; y < 256; y++) {
+      for (int x = 0; x < 16; x++) {
+        for (int z = 0; z < 16; z++) {
+          SimpleBlock block = simpleChunk.getBlock(x, y, z);
+          if (!block.isAir()) {
+            surface.set(x + z * 16, y + 1);
+          }
+          if (block.isMotionBlocking()) {
+            motionBlocking.set(x + z * 16, y + 1);
+          }
+        }
+      }
+    }
+    return CompoundBinaryTag.builder().putLongArray("MOTION_BLOCKING", motionBlocking.getData())
+        .putLongArray("WORLD_SURFACE", surface.getData()).build();
+  }
+
+
+  private int writeChunkData(ByteBuf data, ProtocolVersion version) {
+    networkSections.clear();
+    ChunkSection[] sections = simpleChunk.getSections();
+    List<NetworkSection> nSections = new ArrayList<>(16);
+    boolean skyLight = simpleChunk.getInstance().getDimension().isHasSkylight();
+    int bitMask = 0;
+    int dataLength = data.capacity();
+    //Calculate bitMask, data length and convert chunk sections to network sections
+    for (int s = 0; s < sections.length; s++) {
+      ChunkSection section = sections[s];
+      if (section != null && section.hasAnyData()) {
+        bitMask |= 1 << s;
+        NetworkSection networkSection = NetworkSection.create(version, section, skyLight);
+        dataLength += networkSection.getDataLength();
+        nSections.add(networkSection);
+      }
+    }
+
+    data.ensureWritable(dataLength); //resize buffer
+    //Write chunk sections data to buffer
+    for (int pass = 0; pass < 4; pass++) {
+      int finalPass = pass;
+      nSections.forEach(n -> n.writeData(data, finalPass));
+    }
+    if (version.isBefore(ProtocolVersion.MINECRAFT_1_15)) {
+      writeChunkBiomes(data, version);
+    }
+    return bitMask;
+  }
+
+  private void writeChunkBiomes(ByteBuf data, ProtocolVersion version) {
+    Object biomes = createBiomesArray(version);
+    if (version.isBefore(ProtocolVersion.MINECRAFT_1_15)) {
+      if (version.isBefore(ProtocolVersion.MINECRAFT_1_13)) {
+        data.ensureWritable(256);
+        data.writeBytes((byte[]) biomes);
+      } else {
+        data.ensureWritable(256 * 4);
+        for (byte b : (byte[]) biomes) {
+          data.writeInt(b);
+        }
+      }
+    } else {
+      data.ensureWritable(1024 * 4);
+      for (int i : ((int[]) biomes)) {
+        data.writeInt(i);
+      }
+    }
+  }
+
+  private Object createBiomesArray(ProtocolVersion version) {
+    ChunkSection[] sections = simpleChunk.getSections();
+    Object biomes = null;
+    if (version.isBefore(ProtocolVersion.MINECRAFT_1_15)) {
+      biomes = new byte[256];
+      Arrays.fill((byte[]) biomes, (byte) 1);
+    } else {
+      biomes = new int[1024];
+      Arrays.fill((int[]) biomes, 1);
+    }
+    for (int s = 0; s < sections.length; s++) {
+      ChunkSection section = sections[s];
+      if (section != null) {
+        int biome = section.getBiome().id;
+        if (version.isBefore(ProtocolVersion.MINECRAFT_1_15)) {
+          Arrays.fill((byte[]) biomes, s * 16, (s * 16) + 16, (byte) biome);
+        } else {
+          Arrays.fill((int[]) biomes, s * 16 * 4, (s * 16 * 4) + 64, biome);
+        }
+      }
+    }
+    return biomes;
+  }
+
+  private int getInitialDataSize(ProtocolVersion version) {
+    if (version.isBefore(ProtocolVersion.MINECRAFT_1_13)) {
+      return 256;
+    }
+    if (version.isBeforeOrEq(ProtocolVersion.MINECRAFT_1_14_4)) {
+      return 256 * 4;
+    }
+    return 0;
+  }
+
+  private void write17(ByteBuf out, ByteBuf data) {
+    out.writeShort(0); //Extended bitmask
+
+    byte[] uncompressed = new byte[data.readableBytes()];
+    data.readBytes(uncompressed);
+    ByteBuf compressed = Unpooled.buffer();
+    Deflater deflater = new Deflater(9);
+    deflater.setInput(uncompressed);
+    deflater.finish();
+    byte[] buffer = new byte[1024];
+    while (!deflater.finished()) {
+      int count = deflater.deflate(buffer);
+      compressed.writeBytes(buffer, 0, count);
+    }
+    deflater.end();
+    out.writeInt(compressed.readableBytes()); // compressed size
+    out.writeBytes(compressed);
+    compressed.release();
+  }
+}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/packet/world/ChunkData.java b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/packet/world/ChunkData.java
new file mode 100644
index 00000000..7aef92a9
--- /dev/null
+++ b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/packet/world/ChunkData.java
@@ -0,0 +1,62 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.elytrium.elytraproxy.botfilter.protocol.packet.world;
+
+import com.velocitypowered.api.network.ProtocolVersion;
+import com.velocitypowered.proxy.connection.MinecraftSessionHandler;
+import com.velocitypowered.proxy.protocol.MinecraftPacket;
+import com.velocitypowered.proxy.protocol.ProtocolUtils.Direction;
+import io.netty.buffer.ByteBuf;
+
+public class ChunkData implements MinecraftPacket {
+
+  private int x;
+  private int z;
+
+  public ChunkData(int x, int z) {
+    this.x = x;
+    this.z = z;
+  }
+
+  public ChunkData() {
+  }
+
+  @Override
+  public void encode(ByteBuf buf, Direction direction, ProtocolVersion protocolVersion) {
+    throw new UnsupportedOperationException("should be override");
+  }
+
+  @Override
+  public void decode(ByteBuf buf, Direction direction, ProtocolVersion protocolVersion) {
+    throw new UnsupportedOperationException("should not be decoded");
+  }
+
+  @Override
+  public boolean handle(MinecraftSessionHandler handler) {
+    throw new UnsupportedOperationException("cant be called");
+  }
+
+  public int getX() {
+    return x;
+  }
+
+  public int getZ() {
+    return z;
+  }
+}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/packet/world/EmptyChunk113.java b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/packet/world/EmptyChunk113.java
new file mode 100644
index 00000000..83bf8695
--- /dev/null
+++ b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/packet/world/EmptyChunk113.java
@@ -0,0 +1,97 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.elytrium.elytraproxy.botfilter.protocol.packet.world;
+
+import com.velocitypowered.api.network.ProtocolVersion;
+import com.velocitypowered.proxy.protocol.ProtocolUtils;
+import com.velocitypowered.proxy.protocol.ProtocolUtils.Direction;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufOutputStream;
+import java.io.IOException;
+
+/**
+ * 1.13 - 1.16.4
+ */
+public class EmptyChunk113 extends ChunkData {
+
+
+  public EmptyChunk113(int x, int z) {
+    super(x, z);
+  }
+
+  @Override
+  public void encode(ByteBuf buf, Direction direction, ProtocolVersion version) {
+    buf.writeInt(getX());
+    buf.writeInt(getZ());
+    buf.writeBoolean(true);
+
+    if (version == ProtocolVersion.MINECRAFT_1_16 || version == ProtocolVersion.MINECRAFT_1_16_1) {
+      buf.writeBoolean(true);
+    }
+
+    ProtocolUtils.writeVarInt(buf, 0);
+
+    if (version.isAfterOrEq(ProtocolVersion.MINECRAFT_1_14)) {
+      writeHeighmaps(buf);
+    }
+    //Biomes
+    if (version.isAfterOrEq(ProtocolVersion.MINECRAFT_1_15)) {
+      if (version.isBefore(ProtocolVersion.MINECRAFT_1_16_2)) {
+        for (int i = 0; i < 1024; i++) {
+          buf.writeInt(0);
+        }
+      } else {
+        ProtocolUtils.writeVarInt(buf, 1024);
+        for (int i = 0; i < 1024; i++) {
+          ProtocolUtils.writeVarInt(buf, 1);
+        }
+      }
+    }
+
+    if (version == ProtocolVersion.MINECRAFT_1_13) {
+      ProtocolUtils.writeByteArray(buf, new byte[512]);
+    } else {
+      ProtocolUtils.writeByteArray(buf, new byte[1024]);
+    }
+
+    ProtocolUtils.writeVarInt(buf, 0);
+  }
+
+  //todo use Compound
+  private void writeHeighmaps(ByteBuf buf) {
+    try (ByteBufOutputStream output = new ByteBufOutputStream(buf)) {
+      output.writeByte(10); //CompoundTag
+      output.writeUTF(""); // CompoundName
+      output.writeByte(10); //CompoundTag
+      output.writeUTF("root"); //root compound
+      output.writeByte(12); //long array
+      output.writeUTF("MOTION_BLOCKING");
+      long[] longArrayTag = new long[36];
+      output.writeInt(longArrayTag.length);
+      for (int i = 0, length = longArrayTag.length; i < length; i++) {
+        output.writeLong(longArrayTag[i]);
+      }
+      buf.writeByte(0); //end of compound
+      buf.writeByte(0); //end of compound
+    } catch (IOException ex) {
+      throw new RuntimeException(ex);
+    }
+  }
+
+}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/packet/world/UpdateLight.java b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/packet/world/UpdateLight.java
new file mode 100644
index 00000000..a046f7fe
--- /dev/null
+++ b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/packet/world/UpdateLight.java
@@ -0,0 +1,103 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.elytrium.elytraproxy.botfilter.protocol.packet.world;
+
+import com.velocitypowered.api.network.ProtocolVersion;
+import com.velocitypowered.proxy.protocol.MinecraftPacket;
+import com.velocitypowered.proxy.protocol.ProtocolUtils;
+import com.velocitypowered.proxy.protocol.ProtocolUtils.Direction;
+import io.netty.buffer.ByteBuf;
+import ru.elytrium.elytraproxy.botfilter.protocol.util.mcprotocollib.NibbleArray3d;
+import ru.elytrium.elytraproxy.botfilter.server.world.SimpleChunk;
+import ru.elytrium.elytraproxy.botfilter.server.world.SimpleChunk.ChunkSection;
+
+public class UpdateLight implements MinecraftPacket {
+
+  private final SimpleChunk chunk;
+  private final NibbleArray3d[] skyLight = new NibbleArray3d[18];
+  private final NibbleArray3d[] blockLight = new NibbleArray3d[18];
+  private int skyLightMask = 0;
+  private int blockLightMask = 0;
+  private int emptySkyLightMask = 0;
+  private int emptyBlockLightMask = 0;
+
+  public UpdateLight() {
+    chunk = null;
+  }
+
+  public UpdateLight(SimpleChunk simpleChunk) {
+    this.chunk = simpleChunk;
+    prepareLighting();
+  }
+
+  @Override
+  public void encode(ByteBuf buf, Direction direction, ProtocolVersion version) {
+    ProtocolUtils.writeVarInt(buf, chunk.getX());
+    ProtocolUtils.writeVarInt(buf, chunk.getZ());
+
+    ProtocolUtils.writeVarInt(buf, skyLightMask);
+    ProtocolUtils.writeVarInt(buf, blockLightMask);
+    ProtocolUtils.writeVarInt(buf, emptySkyLightMask);
+    ProtocolUtils.writeVarInt(buf, emptyBlockLightMask);
+
+    for (NibbleArray3d array3d : skyLight) {
+      if (array3d != null) {
+        ProtocolUtils.writeByteArray(buf, array3d.getData());
+      }
+    }
+    for (NibbleArray3d nibbleArray3d : blockLight) {
+      if (nibbleArray3d != null) {
+        ProtocolUtils.writeByteArray(buf, nibbleArray3d.getData());
+      }
+    }
+  }
+
+  private void prepareLighting() {
+    ChunkSection[] chunkSections = chunk.getSections();
+    ChunkSection[] allSections = new ChunkSection[18];
+    System.arraycopy(chunkSections, 0, allSections, 1, chunkSections.length);
+    allSections[0] = chunk.getExtraLightSections()[0];
+    allSections[17] = chunk.getExtraLightSections()[1];
+
+    for (int i = 0; i < allSections.length; i++) {
+      ChunkSection section = allSections[i];
+      if (section == null || !section.hasAnyData()) {
+        emptySkyLightMask |= 1 << i;
+        emptyBlockLightMask |= 1 << i;
+      } else {
+        NibbleArray3d sectionSkyLight = section.getSkyLight();
+        if (sectionSkyLight != null) {
+          skyLightMask |= 1 << i;
+          skyLight[i] = sectionSkyLight;
+        } else {
+          emptySkyLightMask |= 1 << i;
+        }
+
+        NibbleArray3d sectionBlockSky = section.getBlockLight();
+        if (sectionBlockSky != null) {
+          blockLightMask |= 1 << i;
+          blockLight[i] = sectionBlockSky;
+        } else {
+          emptyBlockLightMask |= 1 << i;
+        }
+      }
+    }
+
+  }
+}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/registry/Biome.java b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/registry/Biome.java
new file mode 100644
index 00000000..34793e85
--- /dev/null
+++ b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/registry/Biome.java
@@ -0,0 +1,231 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.elytrium.elytraproxy.botfilter.protocol.registry;
+
+import javax.annotation.Nullable;
+import lombok.Data;
+import lombok.NonNull;
+import lombok.RequiredArgsConstructor;
+import net.kyori.adventure.nbt.CompoundBinaryTag;
+import net.kyori.adventure.nbt.CompoundBinaryTag.Builder;
+import ru.elytrium.elytraproxy.botfilter.protocol.registry.Biome.Effects.MoodSound;
+
+public class Biome {
+
+  public static final Biome PLAINTS = new Biome("minecraft:plains", 1,
+      new Element("rain", 0.125f, 0.8f, 0.05f, 0.4f, "plains",
+          Effects.builder(7907327, 329011, 12638463, 415920)
+              .moodSound(MoodSound.of(6000, 2.0d, 8, "minecraft:ambient.cave")).build()));
+
+  public static final Biome SWAMP = new Biome("minecraft:swamp", 6,
+      new Element("rain", -0.2F, 0.8f, 0.1F, 0.9F, "swamp",
+          Effects.builder(7907327, 329011, 12638463, 415920).grassColorModifier("swamp")
+              .foliageColor(6975545)
+              .moodSound(MoodSound.of(6000, 2.0d, 8, "minecraft:ambient.cave")).build()));
+
+  public static final Biome SWAMP_HILLS = new Biome("minecraft:swamp_hills", 134,
+      new Element("rain", -0.1F, 0.8f, 0.3F, 0.9F, "swamp",
+          Effects.builder(7907327, 329011, 12638463, 415920).grassColorModifier("swamp")
+              .foliageColor(6975545)
+              .moodSound(MoodSound.of(6000, 2.0d, 8, "minecraft:ambient.cave")).build()));
+  public final String name;
+  public final int id;
+  public final Element element;
+
+
+  public Biome(String name, int id, Element element) {
+    this.name = name;
+    this.id = id;
+    this.element = element;
+  }
+
+  public CompoundBinaryTag encodeBiome() {
+    return CompoundBinaryTag.builder()
+        .putString("name", name)
+        .putInt("id", id)
+        .put("element", element.encode()).build();
+  }
+
+
+  public static class Element {
+
+    public final String precipitation;
+    public final float depth;
+    public final float temperature;
+    public final float scale;
+    public final float downfall;
+    public final String category;
+    public final Effects effects;
+
+    public Element(String precipitation, float depth, float temperature, float scale,
+        float downfall,
+        String category, Effects effects) {
+      this.precipitation = precipitation;
+      this.depth = depth;
+      this.temperature = temperature;
+      this.scale = scale;
+      this.downfall = downfall;
+      this.category = category;
+      this.effects = effects;
+    }
+
+    public CompoundBinaryTag encode() {
+      return CompoundBinaryTag.builder()
+          .putString("precipitation", precipitation)
+          .putFloat("depth", depth)
+          .putFloat("temperature", temperature)
+          .putFloat("scale", scale)
+          .putFloat("downfall", downfall)
+          .putString("category", category)
+          .put("effects", effects.encode()).build();
+    }
+  }
+
+  @Data
+  @RequiredArgsConstructor
+  @lombok.Builder
+  public static class Effects {
+
+    private final int skyColor;
+    private final int waterFogColor;
+    private final int fogColor;
+    private final int waterColor;
+
+    @Nullable private final Integer foliageColor;
+    @Nullable private final String grassColorModifier;
+    @Nullable private final Music music;
+    @Nullable private final String ambientSound;
+    @Nullable private final AdditionsSound additionsSound;
+    @Nullable private final MoodSound moodSound;
+    @Nullable private final Particle particle;
+
+    public CompoundBinaryTag encode() {
+      Builder result = CompoundBinaryTag.builder();
+      result.putInt("sky_color", skyColor)
+          .putInt("water_fog_color", waterColor)
+          .putInt("fog_color", fogColor)
+          .putInt("water_color", waterColor);
+
+      if (foliageColor != null) {
+        result.putInt("foliage_color", foliageColor);
+      }
+      if (grassColorModifier != null) {
+        result.putString("grass_color_modifier", grassColorModifier);
+      }
+      if (music != null) {
+        result.put("music", music.encode());
+      }
+      if (ambientSound != null) {
+        result.putString("ambient_sound", ambientSound);
+      }
+      if (additionsSound != null) {
+        result.put("additions_sound", additionsSound.encode());
+      }
+      if (moodSound != null) {
+        result.put("mood_sound", moodSound.encode());
+      }
+      if (particle != null) {
+        result.put("particle", particle.encode());
+      }
+      return result.build();
+    }
+
+    public static EffectsBuilder builder(int skyColor, int waterFogColor, int fogColor,
+        int waterColor) {
+      return new EffectsBuilder().skyColor(skyColor).waterFogColor(waterFogColor).fogColor(fogColor)
+          .waterColor(waterColor);
+    }
+
+    @Data
+    @RequiredArgsConstructor(staticName = "of")
+    public static class MoodSound {
+
+      private final int tickDelay;
+      private final double offset;
+      private final int blockSearchExtent;
+      @NonNull private final String sound;
+
+      public CompoundBinaryTag encode() {
+        return CompoundBinaryTag.builder()
+            .putInt("tick_delay", tickDelay)
+            .putDouble("offset", offset)
+            .putInt("block_search_extent", blockSearchExtent)
+            .putString("sound", sound).build();
+      }
+    }
+
+    @Data
+    @RequiredArgsConstructor(staticName = "of")
+    public static class Music {
+
+      private final boolean replaceCurrentMusic;
+      @NonNull private final String sound;
+      private final int maxDelay;
+      private final int minDelay;
+
+      public CompoundBinaryTag encode() {
+        return CompoundBinaryTag.builder()
+            .putBoolean("replace_current_music", replaceCurrentMusic)
+            .putString("sound", sound)
+            .putInt("max_delay", maxDelay)
+            .putInt("min_delay", minDelay).build();
+      }
+    }
+
+    @Data
+    @RequiredArgsConstructor(staticName = "of")
+    public static class AdditionsSound {
+
+      @NonNull private final String sound;
+      private final double tickChance;
+
+      public CompoundBinaryTag encode() {
+        return CompoundBinaryTag.builder()
+            .putString("sound", sound)
+            .putDouble("tick_chance", tickChance).build();
+      }
+    }
+
+    @Data
+    @RequiredArgsConstructor(staticName = "of")
+    public static class Particle {
+
+      private final float probability;
+      @NonNull private final ParticleOptions options;
+
+      public CompoundBinaryTag encode() {
+        return CompoundBinaryTag.builder()
+            .putFloat("probability", probability)
+            .put("options", options.encode()).build();
+      }
+
+      @Data
+      @RequiredArgsConstructor
+      public static class ParticleOptions {
+
+        @NonNull private final String type;
+
+        public CompoundBinaryTag encode() {
+          return CompoundBinaryTag.builder()
+              .putString("type", type).build();
+        }
+      }
+    }
+  }
+}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/registry/Dimension.java b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/registry/Dimension.java
new file mode 100644
index 00000000..ad882942
--- /dev/null
+++ b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/registry/Dimension.java
@@ -0,0 +1,91 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.elytrium.elytraproxy.botfilter.protocol.registry;
+
+import com.velocitypowered.api.network.ProtocolVersion;
+import lombok.AllArgsConstructor;
+import lombok.Data;
+import lombok.NonNull;
+import net.kyori.adventure.nbt.CompoundBinaryTag;
+import net.kyori.adventure.nbt.CompoundBinaryTag.Builder;
+
+
+@AllArgsConstructor
+@Data
+public class Dimension {
+
+  public static final Dimension OVERWORLD = new Dimension("minecraft:overworld", 0, false, true,
+      0.0f, null, false, "minecraft:infiniburn_overworld",
+      false, true, true, "minecraft:overworld", true, 256, 1.0f, false, false);
+
+  @NonNull
+  private final String key;
+  private final int id;
+
+  private final boolean piglinSafe;
+  private final boolean natural;
+  private final float ambientLight;
+  private final Long fixedTime;
+  private final boolean shrunk;
+  @NonNull
+  private final String infiniburn;
+  private final boolean respawnAnchorWorks;
+  private final boolean hasSkylight;
+  private final boolean bedWorks;
+  @NonNull
+  private final String effects;
+  private final boolean hasRaids;
+  private final int logicalHeight;
+  private final float coordinateScale;
+  private final boolean ultrawarm;
+  private final boolean hasCeiling;
+
+
+  public CompoundBinaryTag encodeAttributes(ProtocolVersion protocolVersion) {
+    Builder tag = CompoundBinaryTag.builder()
+        .putString("name", key)
+        .putBoolean("natural", natural)
+        .putBoolean("has_skylight", hasSkylight)
+        .putBoolean("has_ceiling", hasCeiling);
+    if (fixedTime != null) {
+      tag.putLong("fixed_time", fixedTime);
+    }
+
+    tag.putBoolean("shrunk", shrunk)
+        .putFloat("ambient_light", ambientLight)
+        .putBoolean("ultrawarm", ultrawarm)
+        .putBoolean("has_raids", hasRaids)
+        .putBoolean("respawn_anchor_works", respawnAnchorWorks)
+        .putBoolean("bed_works", bedWorks)
+        .putBoolean("piglin_safe", piglinSafe)
+        .putString("infiniburn", infiniburn)
+        .putInt("logical_height", logicalHeight);
+
+    if (protocolVersion.isAfterOrEq(ProtocolVersion.MINECRAFT_1_16_2)) {
+      tag.remove("name")
+          .remove("shrunk")
+          .putString("effects", effects)
+          .putFloat("coordinate_scale", coordinateScale);
+    }
+
+    return tag.build();
+  }
+
+
+}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/registry/DimensionRegistry.java b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/registry/DimensionRegistry.java
new file mode 100644
index 00000000..04e927f6
--- /dev/null
+++ b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/registry/DimensionRegistry.java
@@ -0,0 +1,133 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.elytrium.elytraproxy.botfilter.protocol.registry;
+
+import com.google.common.base.Preconditions;
+import com.velocitypowered.api.network.ProtocolVersion;
+import com.velocitypowered.proxy.connection.registry.DimensionInfo;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+import java.util.stream.Collectors;
+import net.kyori.adventure.nbt.BinaryTagTypes;
+import net.kyori.adventure.nbt.CompoundBinaryTag;
+import net.kyori.adventure.nbt.ListBinaryTag;
+
+public class DimensionRegistry {
+
+  private final Map<Dimension, List<Biome>> dimensions = new HashMap<>();
+  private Dimension activeDimension;
+  private DimensionInfo activeDimensionInfo;
+
+  public void addDimension(Dimension dimension, List<Biome> biomes) {
+    Preconditions.checkNotNull(dimension);
+    Preconditions.checkNotNull(biomes);
+    Preconditions.checkState(!biomes.isEmpty());
+    dimensions.put(dimension, biomes);
+  }
+
+  public void removeDimension(Dimension dimension) {
+    dimensions.remove(dimension);
+  }
+
+  public Dimension getDimension(int id) {
+    return dimensions.keySet().stream().filter(dim -> dim.getId() == id).findAny().orElse(null);
+  }
+
+  public Dimension getDimension(String key) {
+    return dimensions.keySet().stream().filter(dim -> key.equals(dim.getKey())).findAny()
+        .orElse(null);
+  }
+
+  public List<Biome> getBiomes(Dimension dimension) {
+    return dimensions.get(dimension);
+  }
+
+  public List<String> getWorldNames() {
+    return dimensions.keySet().stream().map(dim -> dim.getKey()).collect(Collectors.toList());
+  }
+
+  public Dimension getActiveDimension() {
+    return activeDimension;
+  }
+
+  public void setActiveDimension(Dimension activeDimension) {
+    Preconditions
+        .checkState(dimensions.containsKey(activeDimension), "Dimension does not registered");
+    this.activeDimension = activeDimension;
+  }
+
+  public DimensionInfo getActiveDimensionInfo() {
+    return activeDimensionInfo;
+  }
+
+  public void setActiveDimensionInfo(DimensionInfo activeDimensionInfo) {
+    Preconditions.checkState(activeDimension != null, "Active dimension does not set");
+    this.activeDimensionInfo = activeDimensionInfo;
+  }
+
+  public CompoundBinaryTag encode(ProtocolVersion protocolVersion) {
+    ListBinaryTag.Builder<CompoundBinaryTag> dimensionsBuilder = ListBinaryTag
+        .builder(BinaryTagTypes.COMPOUND);
+    for (Entry<Dimension, List<Biome>> dimensionEntry : dimensions.entrySet()) {
+      Dimension dimension = dimensionEntry.getKey();
+      CompoundBinaryTag attributes = dimension.encodeAttributes(protocolVersion);
+      if (protocolVersion.isBeforeOrEq(ProtocolVersion.MINECRAFT_1_16_1)) {
+        dimensionsBuilder.add(attributes);
+      } else {
+        CompoundBinaryTag dimensionData = CompoundBinaryTag.builder()
+            .putString("name", dimension.getKey())
+            .putInt("id", dimension.getId())
+            .put("element", attributes).build();
+        dimensionsBuilder.add(dimensionData);
+      }
+    }
+    if (protocolVersion.isBeforeOrEq(ProtocolVersion.MINECRAFT_1_16_1)) {
+      return CompoundBinaryTag.builder().put("dimension", dimensionsBuilder.build()).build();
+    } else {
+      CompoundBinaryTag encodedDimensions = CompoundBinaryTag.builder()
+          .putString("type", "minecraft:dimension_type")
+          .put("value", dimensionsBuilder.build())
+          .build();
+      return CompoundBinaryTag.builder()
+          .put("minecraft:dimension_type", encodedDimensions)
+          .put("minecraft:worldgen/biome", createBiomeRegistry(dimensions.values())).build();
+    }
+  }
+
+  private CompoundBinaryTag createBiomeRegistry(Collection<List<Biome>> allBiomes) {
+    Set<Biome> biomes = new HashSet<>();
+    for (List<Biome> biomeLise : allBiomes) {
+      biomes.addAll(biomeLise);
+    }
+
+    ListBinaryTag.Builder<CompoundBinaryTag> biomesBuilder = ListBinaryTag
+        .builder(BinaryTagTypes.COMPOUND);
+    for (Biome biome : biomes) {
+      biomesBuilder.add(biome.encodeBiome());
+    }
+    return CompoundBinaryTag.builder()
+        .putString("type", "minecraft:worldgen/biome")
+        .put("value", biomesBuilder.build()).build();
+  }
+}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/util/NetworkSection.java b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/util/NetworkSection.java
new file mode 100644
index 00000000..274099a6
--- /dev/null
+++ b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/util/NetworkSection.java
@@ -0,0 +1,292 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.elytrium.elytraproxy.botfilter.protocol.util;
+
+import static ru.elytrium.elytraproxy.botfilter.server.world.SimpleBlock.Version.MINECRAFT_1_7;
+import static ru.elytrium.elytraproxy.botfilter.server.world.SimpleBlock.Version.MINECRAFT_1_8;
+
+import com.velocitypowered.api.network.ProtocolVersion;
+import io.netty.buffer.ByteBuf;
+import lombok.Getter;
+import ru.elytrium.elytraproxy.botfilter.protocol.util.mcprotocollib.BlockStorage;
+import ru.elytrium.elytraproxy.botfilter.protocol.util.mcprotocollib.ByteArray3d;
+import ru.elytrium.elytraproxy.botfilter.protocol.util.mcprotocollib.FlexibleStorage;
+import ru.elytrium.elytraproxy.botfilter.protocol.util.mcprotocollib.NibbleArray3d;
+import ru.elytrium.elytraproxy.botfilter.protocol.util.mcprotocollib.ShortArray3d;
+import ru.elytrium.elytraproxy.botfilter.server.world.SimpleBlock;
+import ru.elytrium.elytraproxy.botfilter.server.world.SimpleBlock.Version;
+import ru.elytrium.elytraproxy.botfilter.server.world.SimpleChunk.ChunkSection;
+
+public abstract class NetworkSection {
+
+  @Getter private final ChunkSection section;
+  @Getter private final boolean skyLight;
+
+  public NetworkSection(ChunkSection section, boolean skyLight) {
+    this.section = section;
+    this.skyLight = skyLight;
+  }
+
+  public abstract int getDataLength();
+
+  public abstract void writeData(ByteBuf data, int pass);
+
+  abstract void setBlockLight(int x, int y, int z, byte blockLight);
+
+  abstract void setSkyLight(int x, int y, int z, byte skyLight);
+
+  abstract void setBlock(int x, int y, int z, SimpleBlock block);
+
+  protected void create() {
+
+    for (int y = 0; y < 16; y++) {
+      for (int x = 0; x < 16; x++) {
+        for (int z = 0; z < 16; z++) {
+          setBlockLight(x, y, z, getSection().getBlockLightAt(x, y, z));
+          setSkyLight(x, y, z, getSection().getSkyLightAt(x, y, z));
+          SimpleBlock simpleBlock = section.getBlockAt(x, y, z);
+          if (simpleBlock == SimpleBlock.AIR) {
+            continue;
+          }
+          setBlock(x, y, z, simpleBlock);
+        }
+      }
+    }
+  }
+
+  public static NetworkSection create(ProtocolVersion version, ChunkSection section, boolean sky) {
+
+    if (version.isBeforeOrEq(ProtocolVersion.MINECRAFT_1_7_6)) {
+      return new NetworkSection1_7(section, sky);
+    } else if (version.isBeforeOrEq(ProtocolVersion.MINECRAFT_1_8)) {
+      return new NetworkSection1_8(section, sky);
+    } else if (version.isBeforeOrEq(ProtocolVersion.MINECRAFT_1_13_2)) {
+      return new NetworkSection1_9(section, sky, Version.map(version));
+    } else {
+      return new NetworkSection1_14(section, sky, Version.map(version));
+    }
+    // return null;
+  }
+
+  public static class NetworkSection1_7 extends NetworkSection {
+
+    private final ByteArray3d blocks = new ByteArray3d(16 * 16 * 16);
+    private final NibbleArray3d metadata = new NibbleArray3d(16 * 16 * 16);
+    private final NibbleArray3d blockLight = new NibbleArray3d(16 * 16 * 16);
+    private final NibbleArray3d skyLight;
+
+    public NetworkSection1_7(ChunkSection section, boolean skyLight) {
+      super(section, skyLight);
+      this.skyLight = skyLight ? new NibbleArray3d(16 * 16 * 16) : null;
+      create();
+    }
+
+
+    @Override
+    void setBlockLight(int x, int y, int z, byte blockLight) {
+      this.blockLight.set(x, y, z, blockLight);
+    }
+
+    @Override
+    void setSkyLight(int x, int y, int z, byte skyLight) {
+      this.skyLight.set(x, y, z, skyLight);
+    }
+
+    @Override
+    void setBlock(int x, int y, int z, SimpleBlock block) {
+      blocks.set(x, y, z, block.getId(MINECRAFT_1_7));
+      metadata.set(x, y, z, block.getData(MINECRAFT_1_7));
+    }
+
+    @Override
+    public void writeData(ByteBuf data, int pass) {
+      if (pass == 0) {
+        data.writeBytes(blocks.getData());
+      }
+      if (pass == 1) {
+        data.writeBytes(metadata.getData());
+      }
+      if (pass == 2) {
+        data.writeBytes(blockLight.getData());
+      }
+      if (pass == 3 && isSkyLight()) {
+        data.writeBytes(skyLight.getData());
+      }
+    }
+
+    @Override
+    public int getDataLength() {
+      int dataLength = 0;
+      dataLength += blocks.getData().length;
+      dataLength += metadata.getData().length;
+      dataLength += blockLight.getData().length;
+      if (isSkyLight()) {
+        dataLength += skyLight.getData().length;
+      }
+      return dataLength;
+    }
+  }
+
+  public static class NetworkSection1_8 extends NetworkSection {
+
+    private final ShortArray3d blocks = new ShortArray3d(16 * 16 * 16);
+    private final NibbleArray3d blockLight = new NibbleArray3d(16 * 16 * 16);
+    private final NibbleArray3d skyLight;
+
+    public NetworkSection1_8(ChunkSection section, boolean skyLight) {
+      super(section, skyLight);
+      this.skyLight = skyLight ? new NibbleArray3d(16 * 16 * 16) : null;
+      create();
+    }
+
+    @Override
+    void setBlockLight(int x, int y, int z, byte blockLight) {
+      this.blockLight.set(x, y, z, blockLight);
+    }
+
+    @Override
+    void setSkyLight(int x, int y, int z, byte skyLight) {
+      this.skyLight.set(x, y, z, skyLight);
+    }
+
+    @Override
+    void setBlock(int x, int y, int z, SimpleBlock block) {
+      blocks.setBlockAndData(x, y, z, block.getId(MINECRAFT_1_8), block.getData(MINECRAFT_1_8));
+    }
+
+    @Override
+    public void writeData(ByteBuf data, int pass) {
+      if (pass == 0) {
+        for (Short s : blocks.getData()) {
+          data.writeShortLE(s);
+        }
+      }
+      if (pass == 1) {
+        data.writeBytes(blockLight.getData());
+      }
+      if (pass == 2 && isSkyLight()) {
+        data.writeBytes(skyLight.getData());
+      }
+    }
+
+    @Override
+    public int getDataLength() {
+      int dataLength = 0;
+      dataLength += blocks.getData().length * 2;
+      dataLength += blockLight.getData().length;
+      if (isSkyLight()) {
+        dataLength += skyLight.getData().length;
+      }
+      return dataLength;
+    }
+  }
+
+  public static class NetworkSection1_9 extends NetworkSection {
+
+    private final BlockStorage blocks;
+    private final NibbleArray3d blockLight = new NibbleArray3d(16 * 16 * 16);
+    private final NibbleArray3d skyLight;
+
+    public NetworkSection1_9(ChunkSection section, boolean skyLight, Version version) {
+      super(section, skyLight);
+      this.blocks = new BlockStorage(version);
+      this.skyLight = skyLight ? new NibbleArray3d(16 * 16 * 16) : null;
+      create();
+    }
+
+    @Override
+    void setBlockLight(int x, int y, int z, byte blockLight) {
+      this.blockLight.set(x, y, z, blockLight);
+    }
+
+    @Override
+    void setSkyLight(int x, int y, int z, byte skyLight) {
+      this.skyLight.set(x, y, z, skyLight);
+    }
+
+    @Override
+    void setBlock(int x, int y, int z, SimpleBlock block) {
+      blocks.set(x, y, z, block);
+    }
+
+    @Override
+    public void writeData(ByteBuf data, int pass) {
+      if (pass == 0) {
+        blocks.write(data);
+        data.writeBytes(blockLight.getData());
+        if (isSkyLight()) {
+          data.writeBytes(skyLight.getData());
+        }
+      }
+    }
+
+    @Override
+    public int getDataLength() {
+      int dataLength = 0;
+      dataLength += blocks.calculateMaxSize();
+      dataLength += blockLight.getData().length;
+      if (isSkyLight()) {
+        dataLength += skyLight.getData().length;
+      }
+      return dataLength;
+    }
+  }
+
+  public static class NetworkSection1_14 extends NetworkSection {
+
+    private final BlockStorage blocks;
+    private int nonAirBlocks = 0;
+    public NetworkSection1_14(ChunkSection section, boolean skyLight, Version version) {
+      super(section, skyLight);
+      this.blocks = new BlockStorage(version);
+      create();
+    }
+
+    @Override
+    void setBlockLight(int x, int y, int z, byte blockLight) {
+    }
+
+    @Override
+    void setSkyLight(int x, int y, int z, byte skyLight) {
+    }
+
+    @Override
+    void setBlock(int x, int y, int z, SimpleBlock block) {
+      blocks.set(x, y, z, block);
+      if (!block.isAir()) {
+        nonAirBlocks++;
+      }
+    }
+
+    @Override
+    public void writeData(ByteBuf data, int pass) {
+      if (pass == 0) {
+        data.writeShort(nonAirBlocks);
+        blocks.write(data);
+      }
+    }
+
+    @Override
+    public int getDataLength() {
+      int dataLength = 0;
+      dataLength += blocks.calculateMaxSize();
+      return dataLength;
+    }
+  }
+}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/util/mcprotocollib/BlockStorage.java b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/util/mcprotocollib/BlockStorage.java
new file mode 100644
index 00000000..432b960e
--- /dev/null
+++ b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/util/mcprotocollib/BlockStorage.java
@@ -0,0 +1,151 @@
+/*
+ * This file is part of MCProtocolLib, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Steveice10 <https://github.com/Steveice10/MCProtocolLib>
+ * Copyright (c) contributors
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+package ru.elytrium.elytraproxy.botfilter.protocol.util.mcprotocollib;
+
+import com.velocitypowered.proxy.protocol.ProtocolUtils;
+import io.netty.buffer.ByteBuf;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import ru.elytrium.elytraproxy.botfilter.server.world.SimpleBlock;
+import ru.elytrium.elytraproxy.botfilter.server.world.SimpleBlock.Version;
+
+public class BlockStorage {
+
+  private static final SimpleBlock AIR = SimpleBlock.AIR;
+  private final Version version;
+  private int bitsPerEntry;
+  private List<SimpleBlock> states;
+  private FlexibleStorage storage;
+
+  public BlockStorage(Version version) {
+    this.version = version;
+    this.bitsPerEntry = 4;
+
+    this.states = new ArrayList<>();
+    this.states.add(AIR);
+
+    this.storage = new FlexibleStorage(this.bitsPerEntry, 4096);
+  }
+
+  public void write(ByteBuf out) {
+    out.writeByte(this.bitsPerEntry);
+
+
+    if (this.bitsPerEntry > 8) {
+      if (version.isBefore(Version.MINECRAFT_1_13)) {
+        ProtocolUtils.writeVarInt(out, 0);
+      }
+    } else {
+      ProtocolUtils.writeVarInt(out, this.states.size());
+      for (SimpleBlock state : this.states) {
+        writeBlockState(out, state, version);
+      }
+    }
+
+    long[] data = this.storage.getData();
+    ProtocolUtils.writeVarInt(out, data.length);
+    for (long l : data) {
+      out.writeLong(l);
+    }
+  }
+
+  public int calculateMaxSize() {
+    return (5 + this.states.size() * 4) + (this.storage.getData().length * 8);
+  }
+
+  public int getBitsPerEntry() {
+    return this.bitsPerEntry;
+  }
+
+  public List<SimpleBlock> getStates() {
+    return Collections.unmodifiableList(this.states);
+  }
+
+  public FlexibleStorage getStorage() {
+    return this.storage;
+  }
+
+  public void set(int x, int y, int z, SimpleBlock state) {
+    int id = this.bitsPerEntry <= 8 ? this.states.indexOf(state) : stateToRaw(state, version);
+    if (id == -1) {
+      this.states.add(state);
+      if (this.states.size() > 1 << this.bitsPerEntry) {
+        this.bitsPerEntry++;
+
+        List<SimpleBlock> oldStates = this.states;
+        if (this.bitsPerEntry > 8) {
+          oldStates = new ArrayList<SimpleBlock>(this.states);
+          this.states.clear();
+          this.bitsPerEntry = version.isBefore(Version.MINECRAFT_1_13) ? 13 : 14;
+        }
+
+        FlexibleStorage oldStorage = this.storage;
+        this.storage = new FlexibleStorage(this.bitsPerEntry, this.storage.getSize());
+        for (int index = 0; index < this.storage.getSize(); index++) {
+          this.storage.set(index,
+              this.bitsPerEntry <= 8 ? oldStorage.get(index)
+                  : stateToRaw(oldStates.get(index), version));
+        }
+      }
+
+      id = this.bitsPerEntry <= 8 ? this.states.indexOf(state) : stateToRaw(state, version);
+    }
+
+    this.storage.set(index(x, y, z), id);
+  }
+
+  public boolean isEmpty() {
+    for (int index = 0; index < this.storage.getSize(); index++) {
+      if (this.storage.get(index) != 0) {
+        return false;
+      }
+    }
+
+    return true;
+  }
+
+  private static void writeBlockState(ByteBuf out, SimpleBlock blockState, Version version) {
+    if (version.isBefore(Version.MINECRAFT_1_13)) {
+      ProtocolUtils
+          .writeVarInt(out, (blockState.getId(version) << 4) | (blockState.getData(version) & 0xF));
+    } else {
+      ProtocolUtils.writeVarInt(out, blockState.getId(version));
+    }
+  }
+
+  private static int index(int x, int y, int z) {
+    return y << 8 | z << 4 | x;
+  }
+
+  private static int stateToRaw(SimpleBlock state, Version version) {
+    if (version.isBefore(Version.MINECRAFT_1_13)) {
+      return (state.getId(version) << 4) | (state.getData(version) & 0xF);
+    } else {
+      return state.getId(version);
+    }
+  }
+}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/util/mcprotocollib/ByteArray3d.java b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/util/mcprotocollib/ByteArray3d.java
new file mode 100644
index 00000000..f6e34ac1
--- /dev/null
+++ b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/util/mcprotocollib/ByteArray3d.java
@@ -0,0 +1,60 @@
+/*
+ * This file is part of MCProtocolLib, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Steveice10 <https://github.com/Steveice10/MCProtocolLib>
+ * Copyright (c) contributors
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+package ru.elytrium.elytraproxy.botfilter.protocol.util.mcprotocollib;
+
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+import java.util.Arrays;
+
+@SuppressFBWarnings({"EI_EXPOSE_REP2", "EI_EXPOSE_REP"})
+public class ByteArray3d {
+
+  private byte[] data;
+
+  public ByteArray3d(int size) {
+    this.data = new byte[size];
+  }
+
+  public ByteArray3d(byte[] array) {
+    this.data = array;
+  }
+
+  public byte[] getData() {
+    return this.data;
+  }
+
+  public int get(int x, int y, int z) {
+    return this.data[y << 8 | z << 4 | x] & 0xFF;
+  }
+
+  public void set(int x, int y, int z, int val) {
+    this.data[y << 8 | z << 4 | x] = (byte) val;
+  }
+
+  public void fill(int val) {
+    Arrays.fill(this.data, (byte) val);
+  }
+
+}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/util/mcprotocollib/FlexibleStorage.java b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/util/mcprotocollib/FlexibleStorage.java
new file mode 100644
index 00000000..4054b8d6
--- /dev/null
+++ b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/util/mcprotocollib/FlexibleStorage.java
@@ -0,0 +1,122 @@
+/*
+ * This file is part of MCProtocolLib, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Steveice10 <https://github.com/Steveice10/MCProtocolLib>
+ * Copyright (c) contributors
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+package ru.elytrium.elytraproxy.botfilter.protocol.util.mcprotocollib;
+
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+
+@SuppressFBWarnings({"EI_EXPOSE_REP2", "EI_EXPOSE_REP"})
+public class FlexibleStorage {
+
+  private final long[] data;
+  private final int bitsPerEntry;
+  private final int size;
+  private final long maxEntryValue;
+
+  public FlexibleStorage(int bitsPerEntry, int size) {
+    this(bitsPerEntry, new long[roundToNearest(size * bitsPerEntry, 64) / 64]);
+  }
+
+  public FlexibleStorage(int bitsPerEntry, long[] data) {
+    if (bitsPerEntry < 4) {
+      bitsPerEntry = 4;
+    }
+
+    this.bitsPerEntry = bitsPerEntry;
+    this.data = data;
+
+    this.size = this.data.length * 64 / this.bitsPerEntry;
+    this.maxEntryValue = (1L << this.bitsPerEntry) - 1;
+  }
+
+  public long[] getData() {
+    return this.data;
+  }
+
+  public int getBitsPerEntry() {
+    return this.bitsPerEntry;
+  }
+
+  public int getSize() {
+    return this.size;
+  }
+
+  public int get(int index) {
+    if (index < 0 || index > this.size - 1) {
+      throw new IndexOutOfBoundsException();
+    }
+
+    int bitIndex = index * this.bitsPerEntry;
+    int startIndex = bitIndex / 64;
+    int endIndex = ((index + 1) * this.bitsPerEntry - 1) / 64;
+    int startBitSubIndex = bitIndex % 64;
+    if (startIndex == endIndex) {
+      return (int) (this.data[startIndex] >>> startBitSubIndex & this.maxEntryValue);
+    } else {
+      int endBitSubIndex = 64 - startBitSubIndex;
+      return (int) (
+          (this.data[startIndex] >>> startBitSubIndex | this.data[endIndex] << endBitSubIndex)
+              & this.maxEntryValue);
+    }
+  }
+
+  public void set(int index, int value) {
+    if (index < 0 || index > this.size - 1) {
+      throw new IndexOutOfBoundsException();
+    }
+
+    if (value < 0 || value > this.maxEntryValue) {
+      throw new IllegalArgumentException("Value cannot be outside of accepted range.");
+    }
+
+    int bitIndex = index * this.bitsPerEntry;
+    int startIndex = bitIndex / 64;
+    int endIndex = ((index + 1) * this.bitsPerEntry - 1) / 64;
+    int startBitSubIndex = bitIndex % 64;
+    this.data[startIndex] = this.data[startIndex] & ~(this.maxEntryValue << startBitSubIndex)
+        | ((long) value & this.maxEntryValue) << startBitSubIndex;
+    if (startIndex != endIndex) {
+      int endBitSubIndex = 64 - startBitSubIndex;
+      this.data[endIndex] = this.data[endIndex] >>> endBitSubIndex << endBitSubIndex
+          | ((long) value & this.maxEntryValue) >> endBitSubIndex;
+    }
+  }
+
+  private static int roundToNearest(int value, int roundTo) {
+    if (roundTo == 0) {
+      return 0;
+    } else if (value == 0) {
+      return roundTo;
+    } else {
+      if (value < 0) {
+        roundTo *= -1;
+      }
+
+      int remainder = value % roundTo;
+      return remainder != 0 ? value + roundTo - remainder : value;
+    }
+  }
+
+}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/util/mcprotocollib/NibbleArray3d.java b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/util/mcprotocollib/NibbleArray3d.java
new file mode 100644
index 00000000..9886c2c0
--- /dev/null
+++ b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/util/mcprotocollib/NibbleArray3d.java
@@ -0,0 +1,77 @@
+/*
+ * This file is part of MCProtocolLib, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Steveice10 <https://github.com/Steveice10/MCProtocolLib>
+ * Copyright (c) contributors
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+package ru.elytrium.elytraproxy.botfilter.protocol.util.mcprotocollib;
+
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+
+@SuppressFBWarnings({"EI_EXPOSE_REP2", "EI_EXPOSE_REP"})
+public class NibbleArray3d {
+
+  private byte[] data;
+
+  public NibbleArray3d(int size) {
+    this.data = new byte[size >> 1];
+  }
+
+  public NibbleArray3d(byte[] array) {
+    this.data = array;
+  }
+
+  public byte[] getData() {
+    return this.data;
+  }
+
+  public int get(int x, int y, int z) {
+    int key = y << 8 | z << 4 | x;
+    int index = key >> 1;
+    int part = key & 1;
+    return part == 0 ? this.data[index] & 15 : this.data[index] >> 4 & 15;
+  }
+
+  public void set(int x, int y, int z, int val) {
+    int key = y << 8 | z << 4 | x;
+    int index = key >> 1;
+    int part = key & 1;
+    if (part == 0) {
+      this.data[index] = (byte) (this.data[index] & 240 | val & 15);
+    } else {
+      this.data[index] = (byte) (this.data[index] & 15 | (val & 15) << 4);
+    }
+  }
+
+  public void fill(int val) {
+    for (int index = 0; index < this.data.length << 1; index++) {
+      int ind = index >> 1;
+      int part = index & 1;
+      if (part == 0) {
+        this.data[ind] = (byte) (this.data[ind] & 240 | val & 15);
+      } else {
+        this.data[ind] = (byte) (this.data[ind] & 15 | (val & 15) << 4);
+      }
+    }
+  }
+
+}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/util/mcprotocollib/ShortArray3d.java b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/util/mcprotocollib/ShortArray3d.java
new file mode 100644
index 00000000..f5e6538e
--- /dev/null
+++ b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/protocol/util/mcprotocollib/ShortArray3d.java
@@ -0,0 +1,103 @@
+/*
+ * This file is part of MCProtocolLib, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Steveice10 <https://github.com/Steveice10/MCProtocolLib>
+ * Copyright (c) contributors
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+package ru.elytrium.elytraproxy.botfilter.protocol.util.mcprotocollib;
+
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+import java.util.Arrays;
+
+@SuppressFBWarnings({"EI_EXPOSE_REP2", "EI_EXPOSE_REP"})
+public class ShortArray3d {
+
+  private short[] data;
+
+  public ShortArray3d(int size) {
+    this.data = new short[size];
+  }
+
+  public ShortArray3d(short[] array) {
+    this.data = array;
+  }
+
+  public short[] getData() {
+    return this.data;
+  }
+
+  public int get(int x, int y, int z) {
+    return this.data[y << 8 | z << 4 | x] & 0xFFFF;
+  }
+
+  public void set(int x, int y, int z, int val) {
+    this.data[y << 8 | z << 4 | x] = (short) val;
+  }
+
+  public int getBlock(int x, int y, int z) {
+    return this.get(x, y, z) >> 4;
+  }
+
+  public void setBlock(int x, int y, int z, int block) {
+    this.set(x, y, z, block << 4 | this.getData(x, y, z));
+  }
+
+  public int getData(int x, int y, int z) {
+    return this.get(x, y, z) & 0xF;
+  }
+
+  public void setData(int x, int y, int z, int data) {
+    this.set(x, y, z, this.getBlock(x, y, z) << 4 | data);
+  }
+
+  public void setBlockAndData(int x, int y, int z, int block, int data) {
+    this.set(x, y, z, block << 4 | data);
+  }
+
+  public void fill(int val) {
+    Arrays.fill(this.data, (short) val);
+  }
+
+  @Override
+  public boolean equals(Object o) {
+      if (this == o) {
+          return true;
+      }
+      if (o == null || getClass() != o.getClass()) {
+          return false;
+      }
+
+    ShortArray3d that = (ShortArray3d) o;
+
+      if (!Arrays.equals(data, that.data)) {
+          return false;
+      }
+
+    return true;
+  }
+
+  @Override
+  public int hashCode() {
+    return Arrays.hashCode(data);
+  }
+
+}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/server/BotFilterSessionHandler.java b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/server/BotFilterSessionHandler.java
new file mode 100644
index 00000000..f99200d8
--- /dev/null
+++ b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/server/BotFilterSessionHandler.java
@@ -0,0 +1,70 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.elytrium.elytraproxy.botfilter.server;
+
+
+import com.velocitypowered.proxy.connection.MinecraftSessionHandler;
+import com.velocitypowered.proxy.connection.client.ConnectedPlayer;
+import com.velocitypowered.proxy.connection.client.LoginSessionHandler;
+import java.util.Objects;
+import lombok.Data;
+
+@Data
+public class BotFilterSessionHandler implements MinecraftSessionHandler {
+
+
+  private final ConnectedPlayer player;
+  private final LoginSessionHandler originalHandler;
+  private final VirtualServer virtualServer;
+
+  @Override
+  public void disconnected() {
+    virtualServer.disconnected(this);
+  }
+
+  @Override
+  public void deactivated() {
+    virtualServer.disconnected(this);
+  }
+
+  private void finishCheck() {
+    player.getConnection().setSessionHandler(originalHandler);
+    originalHandler.initialize(player);
+    //fakeServer.getBotFilter().restoreOriginalHandlers(user);
+    //afterCheck.run();
+  }
+
+
+  @Override
+  public boolean equals(Object o) {
+    if (this == o) {
+      return true;
+    }
+    if (o == null || getClass() != o.getClass()) {
+      return false;
+    }
+    BotFilterSessionHandler that = (BotFilterSessionHandler) o;
+    return player.getUsername().equals(that.player.getUsername());
+  }
+
+  @Override
+  public int hashCode() {
+    return Objects.hash(player.getUsername());
+  }
+}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/server/ServerPackets.java b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/server/ServerPackets.java
new file mode 100644
index 00000000..fc3fcec9
--- /dev/null
+++ b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/server/ServerPackets.java
@@ -0,0 +1,195 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.elytrium.elytraproxy.botfilter.server;
+
+import com.google.common.collect.ImmutableList;
+import com.velocitypowered.api.network.ProtocolVersion;
+import com.velocitypowered.proxy.connection.registry.DimensionInfo;
+import com.velocitypowered.proxy.protocol.StateRegistry;
+import com.velocitypowered.proxy.protocol.packet.Disconnect;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import lombok.Getter;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer;
+import ru.elytrium.elytraproxy.botfilter.protocol.cache.MultiplePreparedPackets;
+import ru.elytrium.elytraproxy.botfilter.protocol.cache.PacketCompressor;
+import ru.elytrium.elytraproxy.botfilter.protocol.cache.PreparedPacket;
+import ru.elytrium.elytraproxy.botfilter.protocol.packet.JoinGame;
+import ru.elytrium.elytraproxy.botfilter.protocol.packet.PlayerPositionAndLook;
+import ru.elytrium.elytraproxy.botfilter.protocol.packet.world.Chunk17to115;
+import ru.elytrium.elytraproxy.botfilter.protocol.packet.world.ChunkData;
+import ru.elytrium.elytraproxy.botfilter.protocol.packet.world.EmptyChunk113;
+import ru.elytrium.elytraproxy.botfilter.protocol.packet.world.UpdateLight;
+import ru.elytrium.elytraproxy.botfilter.protocol.registry.Biome;
+import ru.elytrium.elytraproxy.botfilter.protocol.registry.Dimension;
+import ru.elytrium.elytraproxy.botfilter.protocol.registry.DimensionRegistry;
+import ru.elytrium.elytraproxy.botfilter.server.world.SimpleBlock;
+import ru.elytrium.elytraproxy.botfilter.server.world.SimpleChunk;
+import ru.elytrium.elytraproxy.botfilter.server.world.VirtualWorld;
+
+@Getter
+public class ServerPackets {
+
+  private final PacketCompressor packetCompressor;
+  private final VirtualServer virtualServer;
+  private VirtualWorld virtualWorld;
+  //JoinGame +  Chunks + Light + PlayerPosAndLook
+  private MultiplePreparedPackets spawnPackets;
+  private PreparedPacket<Disconnect> alreadyConnected;
+
+
+  public ServerPackets(PacketCompressor packetCompressor,
+      VirtualServer virtualServer) {
+    this.packetCompressor = packetCompressor;
+    this.virtualServer = virtualServer;
+  }
+
+
+  public void createPackets() {
+    releaseAll();
+    this.virtualWorld = new VirtualWorld(Dimension.OVERWORLD,
+        new DimensionInfo(Dimension.OVERWORLD.getKey(), Dimension.OVERWORLD.getKey(), true, false));
+    virtualWorld.setSkyLight(0, 60, 0, (byte) 1); //1.7 workaround
+
+    for (int x = 0; x < 16; x++) {
+      for (int z = 0; z < 16; z++) {
+        virtualWorld.setBlock(x, 40, z, SimpleBlock.GRANITE);
+        virtualWorld.setBlock(x, 60, z, SimpleBlock.GRANITE);
+      }
+    }
+    for (int x = 1; x < 15; x++) {
+      for (int z = 1; z < 15; z++) {
+        if (x % 3 == 0 && z % 3 == 0) {
+          virtualWorld.setBlock(x, 40, z, SimpleBlock.BARRIER);
+          virtualWorld.setBlockLight(x, 41, z, (byte) 15);
+        }
+      }
+    }
+    for (int x = 0; x < 16; x++) {
+      for (int y = 40; y <= 60; y++) {
+        virtualWorld.setBlock(x, y, 0, SimpleBlock.GRANITE);
+        virtualWorld.setBlock(0, y, x, SimpleBlock.GRANITE);
+        virtualWorld.setBlock(x, y, 15, SimpleBlock.GRANITE);
+        virtualWorld.setBlock(15, y, x, SimpleBlock.GRANITE);
+      }
+    }
+
+    List<PreparedPacket> preparedPackets = new ArrayList<>();
+    preparedPackets.add(createJoinGamePacket());
+    preparedPackets.addAll(createChunksPackets());
+    preparedPackets.addAll(createUpdateLightPackets());
+    preparedPackets.add(createPlayerPosAndLookPacket());
+    spawnPackets = new MultiplePreparedPackets(preparedPackets.toArray(new PreparedPacket[0]));
+    alreadyConnected = createDisconnectPacket("&cAlready connected", StateRegistry.LOGIN);
+    virtualWorld = null;
+  }
+
+  //TODO use Dimensions ids for < 1.16 version
+  private PreparedPacket<JoinGame> createJoinGamePacket() {
+    DimensionRegistry dimensionRegistry = new DimensionRegistry();
+    dimensionRegistry.addDimension(
+        Dimension.OVERWORLD, ImmutableList.of(Biome.PLAINTS, Biome.SWAMP, Biome.SWAMP_HILLS));
+    dimensionRegistry.setActiveDimension(Dimension.OVERWORLD);
+    dimensionRegistry.setActiveDimensionInfo(
+        new DimensionInfo("minecraft:overworld", "minecraft:overworld", false, false));
+    PreparedPacket<JoinGame> joinGame = new PreparedPacket<>();
+    joinGame.prepare(JoinGame.builder().entityId(0).gamemode((short) 1).dimension(0).
+        partialHashedSeed(1).difficulty((short) 0).maxPlayers(1).levelType("flat").viewDistance(4)
+        .reducedDebugInfo(false).showRespawnScreen(true).hardcore(false)
+        .dimensionRegistry(dimensionRegistry).build());
+
+    return processCompression(joinGame);
+  }
+
+  private PreparedPacket<PlayerPositionAndLook> createPlayerPosAndLookPacket() {
+    PreparedPacket<PlayerPositionAndLook> playerPosAndLook = new PreparedPacket<>();
+    playerPosAndLook.prepare(new PlayerPositionAndLook(6, 60, 6, 0f, 0f, -133, false));
+    return processCompression(playerPosAndLook);
+  }
+
+  private List<PreparedPacket<ChunkData>> createChunksPackets() {
+    List<PreparedPacket<ChunkData>> packets = new ArrayList<>();
+    for (SimpleChunk chunk : virtualWorld.getChunks()) {
+      packets.add(createChunkDataPacket(chunk));
+    }
+    return packets;
+  }
+
+  private PreparedPacket<ChunkData> createChunkDataPacket(SimpleChunk chunk) {
+    PreparedPacket<ChunkData> chunkPacket = new PreparedPacket<>();
+    chunkPacket.prepare(new Chunk17to115(chunk), ProtocolVersion.MINECRAFT_1_7_2,
+        ProtocolVersion.MINECRAFT_1_15_2);
+    chunkPacket.prepare(new EmptyChunk113(chunk.getX(), chunk.getZ()),
+        ProtocolVersion.MINECRAFT_1_16);
+    return processCompression(chunkPacket);
+  }
+
+  private List<PreparedPacket<UpdateLight>> createUpdateLightPackets() {
+    List<PreparedPacket<UpdateLight>> packets = new ArrayList<>();
+    for (SimpleChunk chunk : virtualWorld.getChunks()) {
+      packets.add(createUpdateLightPacket(chunk));
+    }
+    return packets;
+  }
+
+  private PreparedPacket<UpdateLight> createUpdateLightPacket(SimpleChunk chunk) {
+    PreparedPacket<UpdateLight> lightPacket = new PreparedPacket<>();
+    lightPacket.prepare(new UpdateLight(chunk), ProtocolVersion.MINECRAFT_1_14,
+        ProtocolVersion.MINECRAFT_1_15_2);
+    return processCompression(lightPacket);
+  }
+
+  private PreparedPacket<Disconnect> createDisconnectPacket(String message,
+      StateRegistry protocol) {
+    Component component = LegacyComponentSerializer.legacyAmpersand().deserialize(message);
+    PreparedPacket<Disconnect> disconnect = new PreparedPacket<>();
+    disconnect.prepare(Disconnect.create(component, ProtocolVersion.MINECRAFT_1_7_2),
+        ProtocolVersion.MINECRAFT_1_7_2, ProtocolVersion.MINECRAFT_1_15_2, protocol);
+    disconnect.prepare(Disconnect.create(component, ProtocolVersion.MINECRAFT_1_16),
+        ProtocolVersion.MINECRAFT_1_16, ProtocolVersion.MAXIMUM_VERSION, protocol);
+    if (protocol == StateRegistry.LOGIN) {
+      disconnect.finish();
+      return disconnect;
+    }
+    return processCompression(disconnect);
+  }
+
+  private <T extends PreparedPacket<?>> T processCompression(T preparedPacket) {
+    if (packetCompressor.isCompressionEnabled()) {
+      preparedPacket.processCompress(packetCompressor);
+    }
+    preparedPacket.finish();
+    return preparedPacket;
+  }
+
+
+  public void releaseAll() {
+    for (PreparedPacket packet : Arrays.asList(alreadyConnected)) {
+      if (packet != null) {
+        packet.releaseBuffers();
+      }
+    }
+    if (spawnPackets != null) {
+      spawnPackets.release();
+    }
+  }
+
+}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/server/VirtualServer.java b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/server/VirtualServer.java
new file mode 100644
index 00000000..7d70eb52
--- /dev/null
+++ b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/server/VirtualServer.java
@@ -0,0 +1,73 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.elytrium.elytraproxy.botfilter.server;
+
+import com.velocitypowered.proxy.connection.MinecraftConnection;
+import com.velocitypowered.proxy.connection.client.ConnectedPlayer;
+import com.velocitypowered.proxy.connection.registry.DimensionInfo;
+import com.velocitypowered.proxy.protocol.StateRegistry;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import lombok.Getter;
+import ru.elytrium.elytraproxy.ElytraProxy;
+import ru.elytrium.elytraproxy.botfilter.protocol.cache.PacketCompressor;
+import ru.elytrium.elytraproxy.botfilter.protocol.registry.Dimension;
+import ru.elytrium.elytraproxy.botfilter.server.world.VirtualWorld;
+
+public class VirtualServer {
+
+  @Getter private final ElytraProxy elytraProxy;
+  private final ConcurrentMap<String, BotFilterSessionHandler> activeConnections = new ConcurrentHashMap<>();
+  private final ServerPackets packets;
+
+  public VirtualServer(ElytraProxy elytraProxy) {
+    this.elytraProxy = elytraProxy;
+    this.packets = new ServerPackets(
+        new PacketCompressor(elytraProxy.getVelocityServer()::getConfiguration), this);
+  }
+
+
+  public void reload() {
+    for (BotFilterSessionHandler session : activeConnections.values()) {
+      session.getPlayer().getConnection().close();
+    }
+    packets.createPackets();
+  }
+
+
+  public void spawnPlayer(BotFilterSessionHandler user) {
+    String username = user.getPlayer().getUsername().toLowerCase();
+    ConnectedPlayer player = user.getPlayer();
+    MinecraftConnection connection = player.getConnection();
+    if (activeConnections.putIfAbsent(username, user) != null) {
+      connection.closeWith(packets.getAlreadyConnected());
+      //user.closeWith(preparedPackets.getAlreadyConnected());
+      return;
+    }
+    user.getOriginalHandler().completeLoginProtocol(player, false);
+    connection.setState(StateRegistry.BotFilter);
+    packets.getSpawnPackets().write(connection, player.isOnlineMode());
+    connection.flush();
+  }
+
+  public void disconnected(BotFilterSessionHandler botFilterConnection) {
+    activeConnections.remove(botFilterConnection.getPlayer().getUsername().toLowerCase());
+  }
+
+}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/server/world/SimpleBlock.java b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/server/world/SimpleBlock.java
new file mode 100644
index 00000000..267c4679
--- /dev/null
+++ b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/server/world/SimpleBlock.java
@@ -0,0 +1,213 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.elytrium.elytraproxy.botfilter.server.world;
+
+import static ru.elytrium.elytraproxy.botfilter.server.world.SimpleBlock.BlockInfo.fallback;
+import static ru.elytrium.elytraproxy.botfilter.server.world.SimpleBlock.BlockInfo.info;
+import static ru.elytrium.elytraproxy.botfilter.server.world.SimpleBlock.Version.MINECRAFT_1_13;
+import static ru.elytrium.elytraproxy.botfilter.server.world.SimpleBlock.Version.MINECRAFT_1_13_1;
+import static ru.elytrium.elytraproxy.botfilter.server.world.SimpleBlock.Version.MINECRAFT_1_14;
+import static ru.elytrium.elytraproxy.botfilter.server.world.SimpleBlock.Version.MINECRAFT_1_7;
+import static ru.elytrium.elytraproxy.botfilter.server.world.SimpleBlock.Version.MINECRAFT_1_8;
+
+import com.velocitypowered.api.network.ProtocolVersion;
+import java.util.Arrays;
+import java.util.EnumMap;
+import java.util.EnumSet;
+import java.util.Map;
+import java.util.Set;
+import org.jetbrains.annotations.NotNull;
+
+public class SimpleBlock {
+
+  public static final SimpleBlock AIR = air(info(MINECRAFT_1_7, 0));
+  public static final SimpleBlock STONE = solid(info(MINECRAFT_1_7, 1));
+  public static final SimpleBlock GRANITE = solid(fallback(MINECRAFT_1_7, STONE),
+      info(MINECRAFT_1_8, 1, 1), info(MINECRAFT_1_13, 2));
+  public static final SimpleBlock GLASS = solid(info(MINECRAFT_1_7, 20),
+      info(MINECRAFT_1_13, 230));
+  public static final SimpleBlock TORCH = nonSolid(false, info(MINECRAFT_1_7, 50, 14)
+      , info(MINECRAFT_1_13, 1130), info(MINECRAFT_1_13_1, 1131), info(MINECRAFT_1_14, 1134));
+  public static final SimpleBlock BARRIER = solid(fallback(MINECRAFT_1_7, GLASS),
+      info(MINECRAFT_1_8, 166), info(MINECRAFT_1_13, 6493), info(MINECRAFT_1_13_1, 6494),
+      info(MINECRAFT_1_14, 7000));
+
+  private final Map<Version, BlockInfo> blockInfos = new EnumMap<>(Version.class);
+  private final boolean solid;
+  private final boolean air;
+  private final boolean motionBlocking; //1.14+
+
+  public SimpleBlock(boolean solid, boolean air, boolean motionBlocking, BlockInfo... blockInfos) {
+    this.motionBlocking = motionBlocking;
+    for (BlockInfo info : blockInfos) {
+      for (Version version : EnumSet.range(info.version, Version.MINECRAFT_1_16)) {
+        this.blockInfos.put(version, info);
+      }
+    }
+    this.air = air;
+    this.solid = solid;
+  }
+
+  public short getId(Version version) {
+    return blockInfos.get(version).getId();
+  }
+
+  public byte getData(Version version) {
+    return blockInfos.get(version).getData();
+  }
+
+  public boolean isSolid() {
+    return solid;
+  }
+
+  public boolean isAir() {
+    return air;
+  }
+
+  public boolean isMotionBlocking() {
+    return motionBlocking;
+  }
+
+  public static SimpleBlock solid(BlockInfo... infos) {
+    return solid(true, infos);
+  }
+
+  public static SimpleBlock solid(boolean motionBlocking, BlockInfo... infos) {
+    return new SimpleBlock(true, false, motionBlocking, infos);
+  }
+
+
+  public static SimpleBlock nonSolid(BlockInfo... infos) {
+    return nonSolid(true, infos);
+  }
+
+  public static SimpleBlock nonSolid(boolean motionBlocking, BlockInfo... infos) {
+    return new SimpleBlock(false, false, motionBlocking, infos);
+  }
+
+  public static SimpleBlock air(BlockInfo... infos) {
+    return new SimpleBlock(false, true, false, infos);
+  }
+
+  public enum Version {
+    MINECRAFT_1_7(ProtocolVersion.MINECRAFT_1_7_2, ProtocolVersion.MINECRAFT_1_7_6),
+    MINECRAFT_1_8(ProtocolVersion.MINECRAFT_1_8),
+    MINECRAFT_1_9(EnumSet.range(ProtocolVersion.MINECRAFT_1_9, ProtocolVersion.MINECRAFT_1_9_4)),
+    MINECRAFT_1_10(ProtocolVersion.MINECRAFT_1_10),
+    MINECRAFT_1_11(ProtocolVersion.MINECRAFT_1_11, ProtocolVersion.MINECRAFT_1_11_1),
+    MINECRAFT_1_12(EnumSet.range(ProtocolVersion.MINECRAFT_1_12, ProtocolVersion.MINECRAFT_1_12_2)),
+    MINECRAFT_1_13(ProtocolVersion.MINECRAFT_1_13),
+    MINECRAFT_1_13_1(ProtocolVersion.MINECRAFT_1_13_1, ProtocolVersion.MINECRAFT_1_13_2),
+    MINECRAFT_1_14(EnumSet.range(ProtocolVersion.MINECRAFT_1_14, ProtocolVersion.MINECRAFT_1_14_4)),
+    MINECRAFT_1_15(EnumSet.range(ProtocolVersion.MINECRAFT_1_15, ProtocolVersion.MINECRAFT_1_15_2)),
+    MINECRAFT_1_16(EnumSet.range(ProtocolVersion.MINECRAFT_1_16, ProtocolVersion.MINECRAFT_1_16_4));
+
+    private static EnumMap<ProtocolVersion, Version> mcVersionToBlockVersions = new EnumMap<>(
+        ProtocolVersion.class);
+
+    static {
+      for (Version version : Version.values()) {
+        for (ProtocolVersion protocolVersion : version.versions) {
+          mcVersionToBlockVersions.put(protocolVersion, version);
+        }
+      }
+    }
+
+    private Set<ProtocolVersion> versions;
+
+    Version(ProtocolVersion... versions) {
+      this.versions = EnumSet.copyOf(Arrays.asList(versions));
+    }
+
+    Version(Set<ProtocolVersion> versions) {
+      this.versions = versions;
+    }
+
+    public boolean isBefore(Version other) {
+      return this.compareTo(other) < 0;
+    }
+
+    public boolean isBeforeOrEq(Version other) {
+      return this.compareTo(other) <= 0;
+    }
+
+    public boolean isAfter(Version other) {
+      return this.compareTo(other) > 0;
+    }
+
+    public boolean isAfterOrEq(Version other) {
+      return this.compareTo(other) >= 0;
+    }
+
+    public static Version map(ProtocolVersion protocolVersion) {
+      return mcVersionToBlockVersions.get(protocolVersion);
+    }
+  }
+
+  public static class BlockInfo {
+
+    @NotNull
+    private final Version version;
+    private final short id;
+    private final byte data;
+    private final BlockInfo fallback;
+
+    public BlockInfo(@NotNull Version version, short id, byte data) {
+      this(version, id, data, null);
+    }
+
+    public BlockInfo(@NotNull Version version, @NotNull BlockInfo fallback) {
+      this(version, (short) 0, (byte) 0, fallback);
+    }
+
+    public BlockInfo(@NotNull Version version, short id, byte data, BlockInfo fallback) {
+      this.version = version;
+      this.id = id;
+      this.data = data;
+      this.fallback = fallback;
+    }
+
+    public @NotNull Version getVersion() {
+      return version;
+    }
+
+    public short getId() {
+      return fallback == null ? id : fallback.getId();
+    }
+
+    public byte getData() {
+      return fallback == null ? data : fallback.getData();
+    }
+
+    public static BlockInfo info(Version version, int id, int meta) {
+      return new BlockInfo(version, (short) id, (byte) meta);
+    }
+
+    public static BlockInfo info(Version version, int id) {
+      return info(version, id, 0);
+    }
+
+
+    public static BlockInfo fallback(Version version, SimpleBlock fallback) {
+      return new BlockInfo(version, fallback.blockInfos.get(version));
+    }
+  }
+
+
+}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/server/world/SimpleChunk.java b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/server/world/SimpleChunk.java
new file mode 100644
index 00000000..80c2264c
--- /dev/null
+++ b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/server/world/SimpleChunk.java
@@ -0,0 +1,243 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.elytrium.elytraproxy.botfilter.server.world;
+
+import com.google.common.base.Preconditions;
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+import java.util.function.Function;
+import java.util.function.Supplier;
+import lombok.Getter;
+import lombok.NoArgsConstructor;
+import lombok.NonNull;
+import lombok.Setter;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import ru.elytrium.elytraproxy.botfilter.protocol.registry.Biome;
+import ru.elytrium.elytraproxy.botfilter.protocol.util.mcprotocollib.NibbleArray3d;
+
+public class SimpleChunk {
+
+  public static final int MAX_BLOCKS_PER_SECTION = 16 * 16 * 16;
+
+  @Getter private final VirtualWorld instance;
+  @Getter private final int x;
+  @Getter private final int z;
+  @SuppressFBWarnings("EI_EXPOSE_REP")
+  @Getter
+  private final ChunkSection[] sections = new ChunkSection[16];
+  //For light update packet; y= -16;-1, 256;271
+  @SuppressFBWarnings("EI_EXPOSE_REP")
+  @Getter
+  private final ChunkSection[] extraLightSections = new ChunkSection[2];
+
+  public SimpleChunk(VirtualWorld instance, int x, int z) {
+    this.instance = instance;
+    this.x = x;
+    this.z = z;
+  }
+
+  public void setBlock(int x, int y, int z, @Nullable SimpleBlock block) {
+    ChunkSection section = getSection(y);
+    section.setBlockAt(x, y % 16, z, block);
+  }
+
+  @NotNull
+  public SimpleBlock getBlock(int x, int y, int z) {
+    return sectionAction(y, (s) -> s.getBlockAt(x, y % 16, z), () -> SimpleBlock.AIR);
+  }
+
+  @NotNull
+  public Biome getBiome(int x, int y, int z) {
+    return sectionAction(y, ChunkSection::getBiome, () -> Biome.PLAINTS);
+  }
+
+  public void setBiome(int x, int y, int z, @NonNull Biome biome) {
+    ChunkSection section = getSection(y);
+    section.setBiome(biome);
+  }
+
+  public byte getBlockLight(int x, int y, int z) {
+    return lightSectionAction(y, (s) -> s.getBlockLightAt(x, y % 16, z), () -> (byte) 0);
+  }
+
+  public void setBlockLight(int x, int y, int z, byte light) {
+    getSectionForLighting(y, true).setBlockLightAt(x, y % 16, z, light);
+  }
+
+  public byte getSkyLight(int x, int y, int z) {
+    return lightSectionAction(y, (s) -> s.getSkyLightAt(x, y % 16, z), () -> (byte) 0);
+  }
+
+  public void setSkyLight(int x, int y, int z, byte light) {
+    getSectionForLighting(y, true).setSkyLightAt(x, y % 16, z, light);
+  }
+
+  private ChunkSection getSection(int y) {
+    int s = getSectionIndex(y);
+    ChunkSection section = sections[s];
+    if (section == null) {
+      sections[s] = (section = new ChunkSection());
+    }
+    return section;
+  }
+
+  private <T> T sectionAction(int y, Function<ChunkSection, T> function, Supplier<T> ifNull) {
+    ChunkSection section = sections[getSectionIndex(y)];
+    if (section == null) {
+      return ifNull.get();
+    }
+    return function.apply(section);
+  }
+
+  private <T> T lightSectionAction(int y, Function<ChunkSection, T> function, Supplier<T> ifNull) {
+    ChunkSection section = getSectionForLighting(y, false);
+    if (section == null) {
+      return ifNull.get();
+    }
+    return function.apply(section);
+  }
+
+  private ChunkSection getSectionForLighting(int y, boolean create) {
+    ChunkSection result = null;
+    if (y < 0) {
+      result = extraLightSections[0];
+      if (create && result == null) {
+        result = (extraLightSections[0] = new ChunkSection());
+      }
+      return result;
+    }
+    if (y >= 256) {
+      result = extraLightSections[1];
+      if (create && result == null) {
+        result = (extraLightSections[1] = new ChunkSection());
+      }
+      return result;
+    }
+    return create ? getSection(y) : sections[getSectionIndex(y)];
+  }
+
+  private static int getSectionIndex(int y) {
+    return y / 16;
+  }
+
+
+  @NoArgsConstructor
+  public static class ChunkSection {
+
+    private SimpleBlock[] blocks;
+    @Getter private NibbleArray3d blockLight;
+    @Getter private NibbleArray3d skyLight;
+    @Getter
+    @Setter
+    @NonNull
+    private Biome biome = Biome.PLAINTS;
+    @Getter private short blocksCount = 0;
+
+    public ChunkSection(@NonNull Biome biome) {
+      this.biome = biome;
+    }
+
+    @NotNull
+    public SimpleBlock getBlockAt(int x, int y, int z) {
+      checkIndexes(x, y, z);
+      return getBlockAt(getBlockIndex(x, y, z));
+    }
+
+    @NotNull
+    private SimpleBlock getBlockAt(int index) {
+      return (blocks == null || blocks[index] == null) ? SimpleBlock.AIR : blocks[index];
+    }
+
+    public void setBlockAt(int x, int y, int z, @Nullable SimpleBlock block) {
+      checkIndexes(x, y, z);
+      setBlockAt(getBlockIndex(x, y, z), block);
+    }
+
+    private void setBlockAt(int index, @Nullable SimpleBlock block) {
+      if (block == SimpleBlock.AIR) {
+        setBlockAt(index, null);
+        return;
+      }
+      if (blocks == null) {
+        if (block == null) {
+          return;
+        }
+        blocks = new SimpleBlock[MAX_BLOCKS_PER_SECTION];
+      }
+      SimpleBlock old = blocks[index];
+      blocks[index] = block;
+      if (old != null) {
+        blocksCount--;
+      }
+
+      if (block != null) {
+        blocksCount++;
+      }
+    }
+
+    public byte getBlockLightAt(int x, int y, int z) {
+      checkIndexes(x, y, z);
+      return (byte) (blockLight == null ? 0 : blockLight.get(x, y, z));
+    }
+
+
+    public void setBlockLightAt(int x, int y, int z, byte light) {
+      checkIndexes(x, y, z);
+      Preconditions.checkArgument(light >= 0 && light <= 15, "light should be between 0 and 15");
+      if (blockLight == null) {
+        blockLight = new NibbleArray3d(MAX_BLOCKS_PER_SECTION);
+      }
+      blockLight.set(x, y, z, light);
+    }
+
+    public byte getSkyLightAt(int x, int y, int z) {
+      checkIndexes(x, y, z);
+      return (byte) (skyLight == null ? 0 : skyLight.get(x, y, z));
+    }
+
+
+    public void setSkyLightAt(int x, int y, int z, byte light) {
+      checkIndexes(x, y, z);
+      Preconditions.checkArgument(light >= 0 && light <= 15, "light should be between 0 and 15");
+      if (skyLight == null) {
+        skyLight = new NibbleArray3d(MAX_BLOCKS_PER_SECTION);
+      }
+      skyLight.set(x, y, z, light);
+    }
+
+    public boolean hasAnyData() {
+      return blocksCount > 0 || skyLight != null || blockLight != null;
+    }
+
+    private void checkIndexes(int x, int y, int z) {
+      Preconditions.checkArgument(checkIndex(x), "x should be between 0 and 15");
+      Preconditions.checkArgument(checkIndex(y), "y should be between 0 and 15");
+      Preconditions.checkArgument(checkIndex(z), "z should be between 0 and 15");
+    }
+
+    private boolean checkIndex(int i) {
+      return i >= 0 && i <= 15;
+    }
+
+    public static int getBlockIndex(int x, int y, int z) {
+      return (y << 8) | (z << 4) | x;
+    }
+  }
+
+}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/server/world/VirtualWorld.java b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/server/world/VirtualWorld.java
new file mode 100644
index 00000000..88c0e5fd
--- /dev/null
+++ b/proxy/src/main/java/ru/elytrium/elytraproxy/botfilter/server/world/VirtualWorld.java
@@ -0,0 +1,136 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.elytrium.elytraproxy.botfilter.server.world;
+
+import com.google.common.collect.ImmutableList;
+import com.velocitypowered.proxy.connection.registry.DimensionInfo;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.function.Function;
+import java.util.function.Supplier;
+import lombok.Getter;
+import lombok.NonNull;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import ru.elytrium.elytraproxy.botfilter.protocol.registry.Biome;
+import ru.elytrium.elytraproxy.botfilter.protocol.registry.Dimension;
+
+public class VirtualWorld {
+
+  @NonNull
+  @Getter
+  private final Dimension dimension;
+  @NonNull
+  @Getter
+  private final DimensionInfo dimensionInfo;
+  private final Map<Long, SimpleChunk> chunks = new HashMap<>();
+
+  public VirtualWorld(@NonNull Dimension dimension, @NonNull DimensionInfo dimensionInfo) {
+    this.dimension = dimension;
+    this.dimensionInfo = dimensionInfo;
+    getChunkOrNew(0, 0);
+  }
+
+  public void setBlock(int x, int y, int z, @Nullable SimpleBlock block) {
+    getChunkOrNew(x, z).setBlock(getChunkCoordinate(x), y, getChunkCoordinate(z), block);
+  }
+
+  @NotNull
+  public SimpleBlock getBlock(int x, int y, int z) {
+    return chunkAction(x, z, (c) -> c.getBlock(getChunkCoordinate(x), y, getChunkCoordinate(z)),
+        () -> SimpleBlock.AIR);
+  }
+
+  public void setBiome(int x, int y, int z, @NonNull Biome biome) {
+    getChunkOrNew(x, z).setBiome(x, y, z, biome);
+  }
+
+  public Biome getBiome(int x, int y, int z) {
+    return chunkAction(x, z, (c) -> c.getBiome(x, y, z), () -> Biome.PLAINTS);
+  }
+
+  public byte getBlockLight(int x, int y, int z) {
+    return chunkAction(x, z,
+        (c) -> c.getBlockLight(getChunkCoordinate(x), y, getChunkCoordinate(z)), () -> (byte) 0);
+  }
+
+  public void setBlockLight(int x, int y, int z, byte light) {
+    getChunkOrNew(x, z).setBlockLight(getChunkCoordinate(x), y, getChunkCoordinate(z), light);
+  }
+
+  public byte getSkyLight(int x, int y, int z) {
+    return chunkAction(x, z,
+        (c) -> c.getSkyLight(getChunkCoordinate(x), y, getChunkCoordinate(z)), () -> (byte) 0);
+  }
+
+
+  public void setSkyLight(int x, int y, int z, byte light) {
+    getChunkOrNew(x, z).setSkyLight(getChunkCoordinate(x), y, getChunkCoordinate(z), light);
+  }
+
+  public List<SimpleChunk> getChunks() {
+    return ImmutableList.copyOf(chunks.values());
+  }
+
+  private <T> T chunkAction(int x, int z, Function<SimpleChunk, T> function, Supplier<T> ifNull) {
+    SimpleChunk chunk = getChunk(x, z);
+    if (chunk == null) {
+      return ifNull.get();
+    }
+    return function.apply(chunk);
+  }
+
+  @Nullable
+  public SimpleChunk getChunk(int x, int z) {
+    return chunks.get(getChunkIndex(getChunkXZ(x), getChunkXZ(z)));
+  }
+
+  @NotNull
+  public SimpleChunk getChunkOrNew(int x, int z) {
+    x = getChunkXZ(x);
+    z = getChunkXZ(z);
+    long index = getChunkIndex(x, z);
+    SimpleChunk simpleChunk = chunks.get(index);
+    if (simpleChunk == null) {
+      chunks.put(index, simpleChunk = new SimpleChunk(this, x, z));
+    }
+    return simpleChunk;
+  }
+
+
+  private static long getChunkIndex(int x, int z) {
+    return (((long) x) << 32) | (z & 0xffffffffL);
+  }
+
+
+  private static int getChunkXZ(int xz) {
+    return Math.floorDiv(xz, 16);
+  }
+
+  private static int getChunkCoordinate(int xz) {
+    xz %= 16;
+    if (xz < 0) {
+      xz += 16;
+    }
+    return xz;
+  }
+
+
+}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/commands/AlertCommand.java b/proxy/src/main/java/ru/elytrium/elytraproxy/commands/AlertCommand.java
index 5cec16ca..7f919ca8 100644
--- a/proxy/src/main/java/ru/elytrium/elytraproxy/commands/AlertCommand.java
+++ b/proxy/src/main/java/ru/elytrium/elytraproxy/commands/AlertCommand.java
@@ -19,8 +19,8 @@ package ru.elytrium.elytraproxy.commands;
 
 import com.velocitypowered.api.command.CommandSource;
 import com.velocitypowered.api.command.SimpleCommand;
-import com.velocitypowered.api.proxy.Player;
 import com.velocitypowered.api.proxy.ProxyServer;
+import com.velocitypowered.proxy.connection.client.ConnectedPlayer;
 
 import net.kyori.adventure.text.Component;
 import net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer;
@@ -58,7 +58,7 @@ public class AlertCommand implements SimpleCommand {
                         .deserialize(prefix + " ¬ßf–ù–∞ —Å–µ—Ä–≤–µ—Ä–µ –Ω–∏–∫–æ–≥–æ –Ω–µ—Ç.")
         );
       } else if (server.getAllPlayers().size() >= 1) {
-        for (Player player : server.getAllPlayers()) {
+        for (ConnectedPlayer player : com.velocitypowered.proxy.VelocityServer.connectionsByUuid.values()) {
           server.sendMessage(player, component);
         }
       }
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/commands/ElytraProxyCommand.java b/proxy/src/main/java/ru/elytrium/elytraproxy/commands/ElytraProxyCommand.java
index 0e3c0b3a..3e2c4b95 100644
--- a/proxy/src/main/java/ru/elytrium/elytraproxy/commands/ElytraProxyCommand.java
+++ b/proxy/src/main/java/ru/elytrium/elytraproxy/commands/ElytraProxyCommand.java
@@ -165,7 +165,7 @@ public class ElytraProxyCommand implements SimpleCommand {
             NamedTextColor.RED));
       }
 
-      elytraProxy.finishLoad(server);
+      elytraProxy.reload();
     }
 
     @Override
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/config/BaseConfig.java b/proxy/src/main/java/ru/elytrium/elytraproxy/config/BaseConfig.java
deleted file mode 100644
index b1ac10aa..00000000
--- a/proxy/src/main/java/ru/elytrium/elytraproxy/config/BaseConfig.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (C) 2021 mdxd44 <banklazhan222>, hevav <Petr Ilin>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ru.elytrium.elytraproxy.config;
-
-import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
-import ru.elytrium.elytraproxy.config.database.MysqlConfig;
-import ru.elytrium.elytraproxy.config.messages.Messages;
-import ru.elytrium.elytraproxy.config.plugins.PluginsConfig;
-
-@SuppressFBWarnings("UWF_UNWRITTEN_FIELD") // temp
-public class BaseConfig {
-  String prefix = "¬ß5¬ßl[Elytrium]";
-  Messages messages = new Messages();
-  MysqlConfig mysql = new MysqlConfig();
-  PluginsConfig plugins = new PluginsConfig();
-
-  public String getPrefix() {
-    return prefix;
-  }
-
-  public Messages getMessages() {
-    return messages;
-  }
-
-  public MysqlConfig getMySql() {
-    return mysql;
-  }
-
-  public PluginsConfig getPlugins() {
-    return plugins;
-  }
-
-}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/config/Config.java b/proxy/src/main/java/ru/elytrium/elytraproxy/config/Config.java
new file mode 100644
index 00000000..267d2b7d
--- /dev/null
+++ b/proxy/src/main/java/ru/elytrium/elytraproxy/config/Config.java
@@ -0,0 +1,390 @@
+/*
+ * Copyright (C) 2021 mdxd44 <banklazhan222>, hevav <Petr Ilin>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ru.elytrium.elytraproxy.config;
+
+import com.velocitypowered.proxy.VelocityServer;
+import ru.elytrium.elytraproxy.config.helpers.Configuration;
+import ru.elytrium.elytraproxy.config.helpers.ConfigurationProvider;
+import ru.elytrium.elytraproxy.config.helpers.YamlConfiguration;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+import java.lang.invoke.MethodHandles;
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.AtomicMoveNotSupportedException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.StandardCopyOption;
+import java.nio.file.StandardOpenOption;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+
+public class Config {
+    private VelocityServer server;
+
+    public Config() {
+        save(new ArrayList<>(), getClass(), this, 0);
+    }
+
+    /**
+     * Set the value of a specific node<br>
+     * Probably throws some error if you supply non existing keys or invalid
+     * values
+     *
+     * @param key   config node
+     * @param value value
+     */
+    private void set(String key, Object value) {
+        String[] split = key.split("\\.");
+        Object instance = getInstance(split, this.getClass());
+        if (instance != null) {
+            Field field = getField(split, instance);
+            if (field != null) {
+                try {
+                    if (field.getAnnotation(Final.class) != null) {
+                        return;
+                    }
+                    if (field.getType() == String.class && !(value instanceof String)) {
+                        value = value + "";
+                    }
+                    field.set(instance, value);
+                    return;
+                } catch (IllegalAccessException | IllegalArgumentException e) {
+                    server.getElytraProxy().getLogger().warn("Error:", e);
+                }
+            }
+        }
+        server.getElytraProxy().getLogger().warn("Failed to set config option: {}: {} | {} ", new Object[]
+                {
+                        key, value, instance
+                });
+    }
+
+    public boolean load(File file) {
+        if (!file.exists()) {
+            return false;
+        }
+        Configuration yml;
+        try {
+            try (InputStreamReader reader = new InputStreamReader(new FileInputStream(file), StandardCharsets.UTF_8)) {
+                yml = ConfigurationProvider.getProvider(YamlConfiguration.class).load(reader);
+            }
+        } catch (IOException ex) {
+            server.getElytraProxy().getLogger().warn("–ù–µ –º–æ–≥—É –∑–∞–≥—Ä—É–∑–∏—Ç—å –∫–æ–Ω—Ñ–∏–≥ ", ex);
+            return false;
+        }
+        set(yml, "");
+        return true;
+    }
+
+    public void set(Configuration yml, String oldPath) {
+        for (String key : yml.getKeys()) {
+            Object value = yml.get(key);
+            String newPath = oldPath + (oldPath.isEmpty() ? "" : ".") + key;
+            if (value instanceof Configuration) {
+                set((Configuration) value, newPath);
+                continue;
+            }
+            set(newPath, value);
+        }
+    }
+
+    /*
+    public int getConfigVersion(File file)
+    {
+        return YamlConfiguration.loadConfiguration( file ).getInt( "config-version", 0 );
+    }
+     */
+
+    /**
+     * Set all values in the file (load first to avoid overwriting)
+     *
+     * @param file file
+     */
+    public void save(File file) {
+        try {
+            File parent = file.getParentFile();
+            if (parent != null) {
+                file.getParentFile().mkdirs();
+            }
+            Path configFile = file.toPath();
+            Path tempCfg = new File(file.getParentFile(), "__tmpcfg").toPath();
+            List<String> lines = new ArrayList<>();
+            save(lines, getClass(), this, 0);
+
+            Files.write(tempCfg, lines, StandardCharsets.UTF_8, StandardOpenOption.CREATE);
+            try {
+                Files.move(tempCfg, configFile, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.ATOMIC_MOVE);
+            } catch (AtomicMoveNotSupportedException e) {
+                Files.move(tempCfg, configFile, StandardCopyOption.REPLACE_EXISTING);
+            }
+
+        } catch (IOException e) {
+            server.getElytraProxy().getLogger().warn("Error:", e);
+        }
+    }
+
+    /**
+     * Indicates that a field should be instantiated / created
+     */
+    @Retention(RetentionPolicy.RUNTIME)
+    @Target({ElementType.FIELD})
+    public @interface Create {
+    }
+
+    /**
+     * Indicates that a field cannot be modified
+     */
+    @Retention(RetentionPolicy.RUNTIME)
+    @Target(
+            {
+                    ElementType.FIELD
+            })
+    public @interface Final {
+    }
+
+    /**
+     * Creates a comment
+     */
+    @Retention(RetentionPolicy.RUNTIME)
+    @Target(
+            {
+                    ElementType.FIELD, ElementType.TYPE
+            })
+    public @interface Comment {
+
+        String[] value();
+    }
+
+    /**
+     * Any field or class with is not part of the config
+     */
+    @Retention(RetentionPolicy.RUNTIME)
+    @Target(
+            {
+                    ElementType.FIELD, ElementType.TYPE
+            })
+    public @interface Ignore {
+    }
+
+    private String toYamlString(Object value, String spacing) {
+        if (value instanceof List) {
+            Collection<?> listValue = (Collection<?>) value;
+            if (listValue.isEmpty()) {
+                return "[]";
+            }
+            StringBuilder m = new StringBuilder();
+            for (Object obj : listValue) {
+                m.append(System.lineSeparator()).append(spacing).append("- ").append(toYamlString(obj, spacing));
+            }
+            return m.toString();
+        }
+        if (value instanceof String) {
+            String stringValue = (String) value;
+            if (stringValue.isEmpty()) {
+                return "''";
+            }
+            return "\"" + stringValue + "\"";
+        }
+        return value != null ? value.toString() : "null";
+    }
+
+    private void save(List<String> lines, Class clazz, final Object instance, int indent) {
+        try {
+            String spacing = repeat(" ", indent);
+            for (Field field : clazz.getFields()) {
+                if (field.getAnnotation(Ignore.class) != null) {
+                    continue;
+                }
+                Class<?> current = field.getType();
+                if (field.getAnnotation(Ignore.class) != null) {
+                    continue;
+                }
+                Comment comment = field.getAnnotation(Comment.class);
+                if (comment != null) {
+                    for (String commentLine : comment.value()) {
+                        lines.add(spacing + "# " + commentLine);
+                    }
+                }
+                Create create = field.getAnnotation(Create.class);
+                if (create != null) {
+                    Object value = field.get(instance);
+                    setAccessible(field);
+                    if (indent == 0) {
+                        lines.add("");
+                    }
+                    comment = current.getAnnotation(Comment.class);
+                    if (comment != null) {
+                        for (String commentLine : comment.value()) {
+                            lines.add(spacing + "# " + commentLine);
+                        }
+                    }
+                    lines.add(spacing + toNodeName(current.getSimpleName()) + ":");
+                    if (value == null) {
+                        field.set(instance, value = current.newInstance());
+                    }
+                    save(lines, current, value, indent + 2);
+                } else {
+                    lines.add(spacing + toNodeName(field.getName() + ": ") + toYamlString(field.get(instance), spacing));
+                }
+            }
+        } catch (Exception e) {
+            server.getElytraProxy().getLogger().warn("Error:", e);
+        }
+    }
+
+    /**
+     * Get the field for a specific config node and instance<br>
+     * Note: As expiry can have multiple blocks there will be multiple instances
+     *
+     * @param split    the node (split by period)
+     * @param instance the instance
+     * @return Field field
+     */
+    private Field getField(String[] split, Object instance) {
+        try {
+            Field field = instance.getClass().getField(toFieldName(split[split.length - 1]));
+            setAccessible(field);
+            return field;
+        } catch (IllegalAccessException | NoSuchFieldException | SecurityException | NoSuchMethodException | InvocationTargetException e) {
+            server.getElytraProxy().getLogger().warn("Invalid config field: {} for {}", new Object[]
+                    {
+                            String.join(".", split), toNodeName(instance.getClass().getSimpleName())
+                    });
+            return null;
+        }
+    }
+
+    /**
+     * Get the instance for a specific config node
+     *
+     * @param split the node (split by period)
+     * @param root  the root class
+     * @return The instance or null
+     */
+    private Object getInstance(String[] split, Class root) {
+        try {
+            Class<?> clazz = root == null ? MethodHandles.lookup().lookupClass() : root;
+            Object instance = this;
+            while (split.length > 0) {
+                switch (split.length) {
+                    case 1:
+                        return instance;
+                    default:
+                        Class found = null;
+                        Class<?>[] classes = clazz.getDeclaredClasses();
+                        for (Class current : classes) {
+                            if (current.getSimpleName().equalsIgnoreCase(toFieldName(split[0]))) {
+                                found = current;
+                                break;
+                            }
+                        }
+                        try {
+                            Field instanceField = clazz.getDeclaredField(toFieldName(split[0]));
+                            setAccessible(instanceField);
+                            Object value = instanceField.get(instance);
+                            if (value == null) {
+                                value = found.newInstance();
+                                instanceField.set(instance, value);
+                            }
+                            clazz = found;
+                            instance = value;
+                            split = Arrays.copyOfRange(split, 1, split.length);
+                            continue;
+                        } catch (NoSuchFieldException | NoSuchMethodException | InvocationTargetException ignore) {
+                        }
+                        return null;
+                }
+            }
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        return null;
+    }
+
+    /**
+     * Translate a node to a java field name
+     *
+     * @param node node to translate
+     * @return java field name
+     */
+    private String toFieldName(String node) {
+        return node.toUpperCase().replaceAll("-", "_");
+    }
+
+    /**
+     * Translate a field to a config node
+     *
+     * @param field to translate
+     * @return config node name
+     */
+    private String toNodeName(String field) {
+        return field.toLowerCase().replace("_", "-");
+    }
+
+    /**
+     * Set some field to be accesible
+     *
+     * @param field to be accesible
+     * @throws NoSuchFieldException   ...
+     * @throws IllegalAccessException ...
+     */
+    private void setAccessible(Field field) throws NoSuchFieldException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {
+        field.setAccessible(true);
+        int modifiers = field.getModifiers();
+        if (Modifier.isFinal(modifiers)) {
+            try {
+                Field modifiersField = Field.class.getDeclaredField("modifiers");
+                modifiersField.setAccessible(true);
+                modifiersField.setInt(field, modifiers & ~Modifier.FINAL);
+            } catch (NoSuchFieldException e) {
+                // Java 12 compatibility *this is fine*
+                Method getDeclaredFields0 = Class.class.getDeclaredMethod("getDeclaredFields0", boolean.class);
+                getDeclaredFields0.setAccessible(true);
+                Field[] fields = (Field[]) getDeclaredFields0.invoke(Field.class, false);
+                for (Field classField : fields) {
+                    if ("modifiers".equals(classField.getName())) {
+                        classField.setAccessible(true);
+                        classField.set(field, modifiers & ~Modifier.FINAL);
+                        break;
+                    }
+                }
+            }
+        }
+    }
+
+    private String repeat(final String s, final int n) {
+        final StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < n; i++) {
+            sb.append(s);
+        }
+        return sb.toString();
+    }
+}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/config/Settings.java b/proxy/src/main/java/ru/elytrium/elytraproxy/config/Settings.java
new file mode 100644
index 00000000..b9676e19
--- /dev/null
+++ b/proxy/src/main/java/ru/elytrium/elytraproxy/config/Settings.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2021 mdxd44 <banklazhan222>, hevav <Petr Ilin>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ru.elytrium.elytraproxy.config;
+
+import java.io.File;
+import java.util.Arrays;
+import java.util.List;
+
+public class Settings extends Config {
+
+    @Ignore
+    public static final Settings IMP = new Settings();
+
+    @Comment("–±–µ—Ç–∞")
+    @Final
+    public String VERSION = "0.0.1";
+
+    @Create
+    public MESSAGES MESSAGES;
+
+    public static class MESSAGES {
+        public String PREFIX = "¬ß5¬ßl[Elytrium]";
+        @Comment({"", "–°–û–û–ë–©–ï–ù–ò–Ø –û–®–ò–ë–û–ö", ""})
+        public String ALREADY_CONNECTED = "–í—ã —É–∂–µ –ø–æ–¥–∫–ª—é—á–µ–Ω—ã –∫ —ç—Ç–æ–º—É —Å–µ—Ä–≤–µ—Ä—É!";
+        public String ALREADY_CONNECTED_PROXY = "–ò–≥—Ä–æ–∫ —Å —Ç–∞–∫–∏–º –Ω–∏–∫–æ–º —É–∂–µ –∏–≥—Ä–∞–µ—Ç –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ!";
+        public String ALREADY_CONNECTING = "–í—ã —É–∂–µ –ø–æ–¥–∫–ª—é—á–∞–µ—Ç–µ—Å—å –∫ —Å–µ—Ä–≤–µ—Ä—É!";
+        public String CANT_CONNECT = "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ —Å–µ—Ä–≤–µ—Ä—É {0}: {1}";
+    }
+
+    @Create
+    public AUTH AUTH;
+
+    public static class AUTH {
+        public boolean ENABLE = true;
+        public boolean ONLINE_MODE_REQUIRES_LOGIN = false;
+        public String TABLE = "auth";
+    }
+
+    @Create
+    public ANTIBOT ANTIBOT;
+
+    public static class ANTIBOT {
+        public boolean ENABLE = true;
+        public boolean ONLINE_MODE_REQUIRES_LOGIN = false;
+        @Comment("How many attempts are allowed before rate limiting?")
+        public int LOGIN_RATELIMIT_ATTEMPTS = 2;
+        @Comment("–ú–∞–ª–µ–Ω—å–∫–∏–º–∏ –±—É–∫–≤–∞–º–∏")
+        public List<String> BANNED_NICK_PATTERNS = Arrays.asList("dropbot", "mcspam", "mcdrop", "mcrage", "mcstorm");
+    }
+
+    @Create
+    public SQL SQL;
+
+    @Comment("–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö")
+    public static class SQL {
+        @Comment("–¢–∏–ø –¥–∞—Ç–∞–±–∞–∑—ã. mysql –∏–ª–∏ mysql))")
+        public String STORAGE_TYPE = "mysql";
+        @Comment("–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–ª—è mysql")
+        public String HOSTNAME = "127.0.0.1";
+        public int PORT = 3306;
+        public String USER = "user";
+        public String PASSWORD = "password";
+        public String DATABASE = "database";
+    }
+
+    public void reload(File file) {
+        load(file);
+        save(file);
+    }
+}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/config/database/MysqlConfig.java b/proxy/src/main/java/ru/elytrium/elytraproxy/config/database/MysqlConfig.java
deleted file mode 100644
index 6a5d3843..00000000
--- a/proxy/src/main/java/ru/elytrium/elytraproxy/config/database/MysqlConfig.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright (C) 2021 mdxd44 <banklazhan222>, hevav <Petr Ilin>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ru.elytrium.elytraproxy.config.database;
-
-public class MysqlConfig {
-    public String hostname;
-    public String user;
-    public String password;
-    public String database;
-}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/config/helpers/Configuration.java b/proxy/src/main/java/ru/elytrium/elytraproxy/config/helpers/Configuration.java
new file mode 100644
index 00000000..0368183b
--- /dev/null
+++ b/proxy/src/main/java/ru/elytrium/elytraproxy/config/helpers/Configuration.java
@@ -0,0 +1,358 @@
+/*
+ * Copyright (C) 2021 mdxd44 <banklazhan222>, hevav <Petr Ilin>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ru.elytrium.elytraproxy.config.helpers;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
+
+
+public final class Configuration {
+
+    private static final char SEPARATOR = '.';
+    final Map<String, Object> self;
+    private final Configuration defaults;
+
+    public Configuration() {
+        this(null);
+    }
+
+    public Configuration(Configuration defaults) {
+        this(new LinkedHashMap<String, Object>(), defaults);
+    }
+
+    Configuration(Map<?, ?> map, Configuration defaults) {
+        this.self = new LinkedHashMap<>();
+        this.defaults = defaults;
+
+        for (Map.Entry<?, ?> entry : map.entrySet()) {
+            String key = (entry.getKey() == null) ? "null" : entry.getKey().toString();
+
+            if (entry.getValue() instanceof Map) {
+                this.self.put(key, new Configuration((Map) entry.getValue(), (defaults == null) ? null : defaults.getSection(key)));
+            } else {
+                this.self.put(key, entry.getValue());
+            }
+        }
+    }
+
+    private Configuration getSectionFor(String path) {
+        int index = path.indexOf(SEPARATOR);
+        if (index == -1) {
+            return this;
+        }
+
+        String root = path.substring(0, index);
+        Object section = self.get(root);
+        if (section == null) {
+            section = new Configuration((defaults == null) ? null : defaults.getSection(root));
+            self.put(root, section);
+        }
+
+        return (Configuration) section;
+    }
+
+    private String getChild(String path) {
+        int index = path.indexOf(SEPARATOR);
+        return (index == -1) ? path : path.substring(index + 1);
+    }
+
+    /*------------------------------------------------------------------------*/
+    @SuppressWarnings("unchecked")
+    public <T> T get(String path, T def) {
+        Configuration section = getSectionFor(path);
+        Object val;
+        if (section == this) {
+            val = self.get(path);
+        } else {
+            val = section.get(getChild(path), def);
+        }
+
+        if (val == null && def instanceof Configuration) {
+            self.put(path, def);
+        }
+
+        return (val != null) ? (T) val : def;
+    }
+
+    public boolean contains(String path) {
+        return get(path, null) != null;
+    }
+
+    public Object get(String path) {
+        return get(path, getDefault(path));
+    }
+
+    public Object getDefault(String path) {
+        return (defaults == null) ? null : defaults.get(path);
+    }
+
+    public void set(String path, Object value) {
+        if (value instanceof Map) {
+            value = new Configuration((Map) value, (defaults == null) ? null : defaults.getSection(path));
+        }
+
+        Configuration section = getSectionFor(path);
+        if (section == this) {
+            if (value == null) {
+                self.remove(path);
+            } else {
+                self.put(path, value);
+            }
+        } else {
+            section.set(getChild(path), value);
+        }
+    }
+
+    /*------------------------------------------------------------------------*/
+    public Configuration getSection(String path) {
+        Object def = getDefault(path);
+        return (Configuration) get(path, (def instanceof Configuration) ? def : new Configuration((defaults == null) ? null : defaults.getSection(path)));
+    }
+
+    /**
+     * Gets keys, not deep by default.
+     *
+     * @return top level keys for this section
+     */
+    public Collection<String> getKeys() {
+        return new LinkedHashSet<>(self.keySet());
+    }
+
+    /*------------------------------------------------------------------------*/
+    public byte getByte(String path) {
+        Object def = getDefault(path);
+        return getByte(path, (def instanceof Number) ? ((Number) def).byteValue() : 0);
+    }
+
+    public byte getByte(String path, byte def) {
+        Object val = get(path, def);
+        return (val instanceof Number) ? ((Number) val).byteValue() : def;
+    }
+
+    public List<Byte> getByteList(String path) {
+        List<?> list = getList(path);
+        List<Byte> result = new ArrayList<>();
+
+        for (Object object : list) {
+            if (object instanceof Number) {
+                result.add(((Number) object).byteValue());
+            }
+        }
+
+        return result;
+    }
+
+    public short getShort(String path) {
+        Object def = getDefault(path);
+        return getShort(path, (def instanceof Number) ? ((Number) def).shortValue() : 0);
+    }
+
+    public short getShort(String path, short def) {
+        Object val = get(path, def);
+        return (val instanceof Number) ? ((Number) val).shortValue() : def;
+    }
+
+    public List<Short> getShortList(String path) {
+        List<?> list = getList(path);
+        List<Short> result = new ArrayList<>();
+
+        for (Object object : list) {
+            if (object instanceof Number) {
+                result.add(((Number) object).shortValue());
+            }
+        }
+
+        return result;
+    }
+
+    public int getInt(String path) {
+        Object def = getDefault(path);
+        return getInt(path, (def instanceof Number) ? ((Number) def).intValue() : 0);
+    }
+
+    public int getInt(String path, int def) {
+        Object val = get(path, def);
+        return (val instanceof Number) ? ((Number) val).intValue() : def;
+    }
+
+    public List<Integer> getIntList(String path) {
+        List<?> list = getList(path);
+        List<Integer> result = new ArrayList<>();
+
+        for (Object object : list) {
+            if (object instanceof Number) {
+                result.add(((Number) object).intValue());
+            }
+        }
+
+        return result;
+    }
+
+    public long getLong(String path) {
+        Object def = getDefault(path);
+        return getLong(path, (def instanceof Number) ? ((Number) def).longValue() : 0);
+    }
+
+    public long getLong(String path, long def) {
+        Object val = get(path, def);
+        return (val instanceof Number) ? ((Number) val).longValue() : def;
+    }
+
+    public List<Long> getLongList(String path) {
+        List<?> list = getList(path);
+        List<Long> result = new ArrayList<>();
+
+        for (Object object : list) {
+            if (object instanceof Number) {
+                result.add(((Number) object).longValue());
+            }
+        }
+
+        return result;
+    }
+
+    public float getFloat(String path) {
+        Object def = getDefault(path);
+        return getFloat(path, (def instanceof Number) ? ((Number) def).floatValue() : 0);
+    }
+
+    public float getFloat(String path, float def) {
+        Object val = get(path, def);
+        return (val instanceof Number) ? ((Number) val).floatValue() : def;
+    }
+
+    public List<Float> getFloatList(String path) {
+        List<?> list = getList(path);
+        List<Float> result = new ArrayList<>();
+
+        for (Object object : list) {
+            if (object instanceof Number) {
+                result.add(((Number) object).floatValue());
+            }
+        }
+
+        return result;
+    }
+
+    public double getDouble(String path) {
+        Object def = getDefault(path);
+        return getDouble(path, (def instanceof Number) ? ((Number) def).doubleValue() : 0);
+    }
+
+    public double getDouble(String path, double def) {
+        Object val = get(path, def);
+        return (val instanceof Number) ? ((Number) val).doubleValue() : def;
+    }
+
+    public List<Double> getDoubleList(String path) {
+        List<?> list = getList(path);
+        List<Double> result = new ArrayList<>();
+
+        for (Object object : list) {
+            if (object instanceof Number) {
+                result.add(((Number) object).doubleValue());
+            }
+        }
+
+        return result;
+    }
+
+    public boolean getBoolean(String path) {
+        Object def = getDefault(path);
+        return getBoolean(path, (def instanceof Boolean) ? (Boolean) def : false);
+    }
+
+    public boolean getBoolean(String path, boolean def) {
+        Object val = get(path, def);
+        return (val instanceof Boolean) ? (Boolean) val : def;
+    }
+
+    public List<Boolean> getBooleanList(String path) {
+        List<?> list = getList(path);
+        List<Boolean> result = new ArrayList<>();
+
+        for (Object object : list) {
+            if (object instanceof Boolean) {
+                result.add((Boolean) object);
+            }
+        }
+
+        return result;
+    }
+
+    public char getChar(String path) {
+        Object def = getDefault(path);
+        return getChar(path, (def instanceof Character) ? (Character) def : '\u0000');
+    }
+
+    public char getChar(String path, char def) {
+        Object val = get(path, def);
+        return (val instanceof Character) ? (Character) val : def;
+    }
+
+    public List<Character> getCharList(String path) {
+        List<?> list = getList(path);
+        List<Character> result = new ArrayList<>();
+
+        for (Object object : list) {
+            if (object instanceof Character) {
+                result.add((Character) object);
+            }
+        }
+        return result;
+    }
+
+    public String getString(String path) {
+        Object def = getDefault(path);
+        return getString(path, (def instanceof String) ? (String) def : "");
+    }
+
+    public String getString(String path, String def) {
+        Object val = get(path, def);
+        return (val instanceof String) ? (String) val : def;
+    }
+
+    public List<String> getStringList(String path) {
+        List<?> list = getList(path);
+        List<String> result = new ArrayList<>();
+
+        for (Object object : list) {
+            if (object instanceof String) {
+                result.add((String) object);
+            }
+        }
+
+        return result;
+    }
+
+    /*------------------------------------------------------------------------*/
+    public List<?> getList(String path) {
+        Object def = getDefault(path);
+        return getList(path, (def instanceof List<?>) ? (List<?>) def : Collections.EMPTY_LIST);
+    }
+
+    public List<?> getList(String path, List<?> def) {
+        Object val = get(path, def);
+        return (val instanceof List<?>) ? (List<?>) val : def;
+    }
+}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/config/helpers/ConfigurationProvider.java b/proxy/src/main/java/ru/elytrium/elytraproxy/config/helpers/ConfigurationProvider.java
new file mode 100644
index 00000000..5cfc61d0
--- /dev/null
+++ b/proxy/src/main/java/ru/elytrium/elytraproxy/config/helpers/ConfigurationProvider.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2021 mdxd44 <banklazhan222>, hevav <Petr Ilin>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ru.elytrium.elytraproxy.config.helpers;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.Reader;
+import java.io.Writer;
+import java.util.HashMap;
+import java.util.Map;
+
+public abstract class ConfigurationProvider {
+
+    private static final Map<Class<? extends ConfigurationProvider>, ConfigurationProvider> providers = new HashMap<>();
+
+    static {
+        try {
+            providers.put(YamlConfiguration.class, new YamlConfiguration());
+        } catch (NoClassDefFoundError ex) {
+            // Ignore, no SnakeYAML
+        }
+    }
+
+    public static ConfigurationProvider getProvider(Class<? extends ConfigurationProvider> provider) {
+        return providers.get(provider);
+    }
+
+    /*------------------------------------------------------------------------*/
+    public abstract void save(Configuration config, File file) throws IOException;
+
+    public abstract void save(Configuration config, Writer writer);
+
+    public abstract Configuration load(File file) throws IOException;
+
+    public abstract Configuration load(File file, Configuration defaults) throws IOException;
+
+    public abstract Configuration load(Reader reader);
+
+    public abstract Configuration load(Reader reader, Configuration defaults);
+
+    public abstract Configuration load(InputStream is);
+
+    public abstract Configuration load(InputStream is, Configuration defaults);
+
+    public abstract Configuration load(String string);
+
+    public abstract Configuration load(String string, Configuration defaults);
+}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/config/helpers/YamlConfiguration.java b/proxy/src/main/java/ru/elytrium/elytraproxy/config/helpers/YamlConfiguration.java
new file mode 100644
index 00000000..70c42f33
--- /dev/null
+++ b/proxy/src/main/java/ru/elytrium/elytraproxy/config/helpers/YamlConfiguration.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2021 mdxd44 <banklazhan222>, hevav <Petr Ilin>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ru.elytrium.elytraproxy.config.helpers;
+
+import com.google.common.base.Charsets;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStreamWriter;
+import java.io.Reader;
+import java.io.Writer;
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+import lombok.AccessLevel;
+import lombok.NoArgsConstructor;
+import org.yaml.snakeyaml.DumperOptions;
+import org.yaml.snakeyaml.Yaml;
+import org.yaml.snakeyaml.constructor.Constructor;
+import org.yaml.snakeyaml.nodes.Node;
+import org.yaml.snakeyaml.representer.Represent;
+import org.yaml.snakeyaml.representer.Representer;
+
+@NoArgsConstructor(access = AccessLevel.PACKAGE)
+public class YamlConfiguration extends ConfigurationProvider {
+
+    private final ThreadLocal<Yaml> yaml = new ThreadLocal<Yaml>() {
+        @Override
+        protected Yaml initialValue() {
+            Representer representer = new Representer() {
+                {
+                    representers.put(Configuration.class, new Represent() {
+                        @Override
+                        public Node representData(Object data) {
+                            return represent(((Configuration) data).self);
+                        }
+                    });
+                }
+            };
+
+            DumperOptions options = new DumperOptions();
+            options.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);
+
+            return new Yaml(new Constructor(), representer, options);
+        }
+    };
+
+    @Override
+    public void save(Configuration config, File file) throws IOException {
+        try (Writer writer = new OutputStreamWriter(new FileOutputStream(file), Charsets.UTF_8)) {
+            save(config, writer);
+        }
+    }
+
+    @Override
+    public void save(Configuration config, Writer writer) {
+        yaml.get().dump(config.self, writer);
+    }
+
+    @Override
+    public Configuration load(File file) throws IOException {
+        return load(file, null);
+    }
+
+    @Override
+    public Configuration load(File file, Configuration defaults) throws IOException {
+        try (FileInputStream is = new FileInputStream(file)) {
+            return load(is, defaults);
+        }
+    }
+
+    @Override
+    public Configuration load(Reader reader) {
+        return load(reader, null);
+    }
+
+    @Override
+    @SuppressWarnings("unchecked")
+    public Configuration load(Reader reader, Configuration defaults) {
+        Map<String, Object> map = yaml.get().loadAs(reader, LinkedHashMap.class);
+        if (map == null) {
+            map = new LinkedHashMap<>();
+        }
+        return new Configuration(map, defaults);
+    }
+
+    @Override
+    public Configuration load(InputStream is) {
+        return load(is, null);
+    }
+
+    @Override
+    @SuppressWarnings("unchecked")
+    public Configuration load(InputStream is, Configuration defaults) {
+        Map<String, Object> map = yaml.get().loadAs(is, LinkedHashMap.class);
+        if (map == null) {
+            map = new LinkedHashMap<>();
+        }
+        return new Configuration(map, defaults);
+    }
+
+    @Override
+    public Configuration load(String string) {
+        return load(string, null);
+    }
+
+    @Override
+    @SuppressWarnings("unchecked")
+    public Configuration load(String string, Configuration defaults) {
+        Map<String, Object> map = yaml.get().loadAs(string, LinkedHashMap.class);
+        if (map == null) {
+            map = new LinkedHashMap<>();
+        }
+        return new Configuration(map, defaults);
+    }
+}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/config/messages/CommandMessages.java b/proxy/src/main/java/ru/elytrium/elytraproxy/config/messages/CommandMessages.java
deleted file mode 100644
index 3cfe4939..00000000
--- a/proxy/src/main/java/ru/elytrium/elytraproxy/config/messages/CommandMessages.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright (C) 2021 mdxd44 <banklazhan222>, hevav <Petr Ilin>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ru.elytrium.elytraproxy.config.messages;
-
-import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
-
-@SuppressFBWarnings("UUF_UNUSED_FIELD") // temp
-public class CommandMessages {
-    public String genericError = "–í–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞.";
-    public String commandDoesNotExist = "–≠—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç.";
-    public String serverDoesNotExist = "–£–∫–∞–∑–∞–Ω–Ω—ã–π —Å–µ—Ä–≤–µ—Ä {0} –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç.";
-    public String serverTooMany = "–ù–∞—Å—Ç—Ä–æ–µ–Ω–æ —Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ —Å–µ—Ä–≤–µ—Ä–æ–≤. –î–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –≤—Å–µ—Ö –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å–µ—Ä–≤–µ—Ä–æ–≤, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∞–≤—Ç–æ–∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –∫–ª–∞–≤–∏—à–µ–π Tab.";
-    public String serverAvailable = "–î–æ—Å—Ç—É–ø–Ω—ã–µ —Å–µ—Ä–≤–µ—Ä—ã: ";
-    public String serverTooltipPlayerOnline = "{0} –∏–≥—Ä–æ–∫ –æ–Ω–ª–∞–π–Ω";
-    public String serverTooltipPlayersOnline = "{0} –∏–≥—Ä–æ–∫(–∞, –æ–≤) –æ–Ω–ª–∞–π–Ω";
-    public String serverTooltipCurrentServer = "–ü–æ–¥–∫–ª—é—á–µ–Ω –∫ —ç—Ç–æ–º—É —Å–µ—Ä–≤–µ—Ä—É";
-    public String serverTooltipOfferConnectServer = "–ö–ª–∏–∫–Ω–∏—Ç–µ, —á—Ç–æ–±—ã –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è –∫ —ç—Ç–æ–º—É —Å–µ—Ä–≤–µ—Ä—É";
-    public String glistPlayerPlural = "{0} –∏–≥—Ä–æ–∫(–∞, –æ–≤) –ø–æ–¥–∫–ª—é—á–µ–Ω—ã –∫ –ø—Ä–æ–∫—Å–∏ –Ω–∞ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç.";
-    public String glistViewAll = "–ß—Ç–æ–±—ã –ø—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å –≤—Å–µ—Ö –∏–≥—Ä–æ–∫–æ–≤ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–∞—Ö, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ /glist all.";
-    public String reloadFailure = "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é Velocity. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∫–æ–Ω—Å–æ–ª—å –¥–ª—è –ø–æ–¥—Ä–æ–±–Ω–æ—Å—Ç–µ–π.";
-    public String versionCopyright = "Copyright 2018-2021 {0}. {1} –ª–∏—Ü–µ–Ω–∑–∏—Ä–æ–≤–∞–Ω–∞ –Ω–∞ —É—Å–ª–æ–≤–∏—è—Ö GNU General Public License v3.";
-    public String noPlugins = "–ù–∏ –æ–¥–Ω–æ–≥–æ –ø–ª–∞–≥–∏–Ω–∞ –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ.";
-    public String pluginsList = "–ü–ª–∞–≥–∏–Ω—ã: {0}";
-    public String pluginTooltipWebsite = "–í–µ–±—Å–∞–π—Ç: {0}";
-    public String pluginTooltipAuthor = "–ê–≤—Ç–æ—Ä: {0}";
-    public String pluginTooltipAuthors = "–ê–≤—Ç–æ—Ä—ã: {0}";
-}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/config/messages/ErrorMessages.java b/proxy/src/main/java/ru/elytrium/elytraproxy/config/messages/ErrorMessages.java
deleted file mode 100644
index a5eefce2..00000000
--- a/proxy/src/main/java/ru/elytrium/elytraproxy/config/messages/ErrorMessages.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright (C) 2021 mdxd44 <banklazhan222>, hevav <Petr Ilin>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ru.elytrium.elytraproxy.config.messages;
-
-import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
-
-@SuppressFBWarnings("UUF_UNUSED_FIELD")
-public class ErrorMessages {
-    public String alreadyConnected = "–í—ã —É–∂–µ –ø–æ–¥–∫–ª—é—á–µ–Ω—ã –∫ —ç—Ç–æ–º—É —Å–µ—Ä–≤–µ—Ä—É!";
-    public String alreadyConnectedProxy = "–ò–≥—Ä–æ–∫ —Å —Ç–∞–∫–∏–º –Ω–∏–∫–æ–º —É–∂–µ –∏–≥—Ä–∞–µ—Ç –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ!";
-    public String alreadyConnecting = "–í—ã —É–∂–µ –ø–æ–¥–∫–ª—é—á–∞–µ—Ç–µ—Å—å –∫ —Å–µ—Ä–≤–µ—Ä—É!";
-    public String cantConnect = "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ —Å–µ—Ä–≤–µ—Ä—É {0}: {1}";
-    public String connectingServerError = "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å –≤–∞—Å –∫ —Å–µ—Ä–≤–µ—Ä—É {0}. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ —á–µ—Ä–µ–∑ –Ω–µ–∫–æ—Ç–æ—Ä–æ–µ –≤—Ä–µ–º—è.";
-    public String connectedServerError = "–° –≤–∞—à–∏–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ–º –∫ —Å–µ—Ä–≤–µ—Ä—É {0} –≤–æ–∑–Ω–∏–∫–ª–∞ –ø—Ä–æ–±–ª–µ–º–∞.";
-    public String internalServerConnectionError = "–ù–∞ —Å–µ—Ä–≤–µ—Ä–µ –ø—Ä–æ–∏–∑–æ—à–ª–∞ –≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è.";
-    public String loggingInTooFast = "–í—ã –≤—Ö–æ–¥–∏—Ç–µ —Å–ª–∏—à–∫–æ–º –±—ã—Å—Ç—Ä–æ, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ —á–µ—Ä–µ–∑ –Ω–µ–∫–æ—Ç–æ—Ä–æ–µ –≤—Ä–µ–º—è.";
-    public String onlineModeOnly = "–í—ã –Ω–µ –≤–æ—à–ª–∏ –≤ —Å–≤–æ–π –∞–∫–∫–∞—É–Ω—Ç Minecraft. –ï—Å–ª–∏ –≤—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ –≤–æ—à–ª–∏ –≤ –∞–∫–∫–∞—É–Ω—Ç, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å —Å–≤–æ–π –∫–ª–∏–µ–Ω—Ç Minecraft.";
-    public String playerConnectionError = "–í –≤–∞—à–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏ –ø—Ä–æ–∏–∑–æ—à–ª–∞ –≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞.";
-    public String modernForwardingNeedsNewClient = "–≠—Ç–æ—Ç —Å–µ—Ä–≤–µ—Ä —Å–æ–≤–º–µ—Å—Ç–∏–º —Ç–æ–ª—å–∫–æ —Å Minecraft 1.13 –∏ –≤—ã—à–µ.";
-    public String modernForwardingFailed = "–í–∞—à —Å–µ—Ä–≤–µ—Ä –Ω–µ –ø–æ—Å—ã–ª–∞–ª –∑–∞–ø—Ä–æ—Å –Ω–∞ –ø–µ—Ä–µ–∞–¥—Ä–µ—Å–∞—Ü–∏—é –Ω–∞ –ø—Ä–æ–∫—Å–∏-—Å–µ—Ä–≤–µ—Ä. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —Å–µ—Ä–≤–µ—Ä –Ω–∞—Å—Ç—Ä–æ–µ–Ω –Ω–∞ –ø–µ—Ä–µ–∞–¥—Ä–µ—Å–∞—Ü–∏—é Velocity.";
-    public String movedToNewServer = "–í—ã –±—ã–ª–∏ –∫–∏–∫–Ω—É—Ç—ã —Å —Å–µ—Ä–≤–µ—Ä–∞ {0}: {1}";
-    public String noAvailableServers = "–ù–µ—Ç —Å–µ—Ä–≤–µ—Ä–æ–≤, –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –¥–ª—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ –∏–ª–∏ —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º.";
-    public String configLoadFailed = "–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –æ–±—Ä–∞—Ç–∏—Ç—å—Å—è –∫ –∫–æ–Ω—Ñ–∏–≥-—Ñ–∞–π–ª—É elytraproxy.yml. –í—ã–∫–ª—é—á–µ–Ω–∏–µ...";
-    public String mysqlLoadFailed = "–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö. –í—ã–∫–ª—é—á–µ–Ω–∏–µ...";
-}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/config/messages/Messages.java b/proxy/src/main/java/ru/elytrium/elytraproxy/config/messages/Messages.java
deleted file mode 100644
index 5ee62495..00000000
--- a/proxy/src/main/java/ru/elytrium/elytraproxy/config/messages/Messages.java
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Copyright (C) 2021 mdxd44 <banklazhan222>, hevav <Petr Ilin>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ru.elytrium.elytraproxy.config.messages;
-
-import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
-
-@SuppressFBWarnings("UUF_UNUSED_FIELD") // temp
-public class Messages {
-  public CommandMessages command = new CommandMessages();
-  public ErrorMessages error = new ErrorMessages();
-}
-
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/config/plugins/AntibotConfig.java b/proxy/src/main/java/ru/elytrium/elytraproxy/config/plugins/AntibotConfig.java
deleted file mode 100644
index be510203..00000000
--- a/proxy/src/main/java/ru/elytrium/elytraproxy/config/plugins/AntibotConfig.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Copyright (C) 2021 mdxd44 <banklazhan222>, hevav <Petr Ilin>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ru.elytrium.elytraproxy.config.plugins;
-
-import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
-
-import java.util.Arrays;
-import java.util.List;
-
-@SuppressFBWarnings("UUF_UNUSED_FIELD") // temp
-public class AntibotConfig {
-    public boolean enable = true;
-    public List<String> bannedNicknames = Arrays.asList(
-            "dropbot",
-            "mcspam",
-            "mcdrop",
-            "mcrage",
-            "mcstorm"
-    );
-    public String table = "antibot";
-}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/config/plugins/AuthConfig.java b/proxy/src/main/java/ru/elytrium/elytraproxy/config/plugins/AuthConfig.java
deleted file mode 100644
index e1b7ef6e..00000000
--- a/proxy/src/main/java/ru/elytrium/elytraproxy/config/plugins/AuthConfig.java
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Copyright (C) 2021 mdxd44 <banklazhan222>, hevav <Petr Ilin>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ru.elytrium.elytraproxy.config.plugins;
-
-import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
-
-@SuppressFBWarnings("UUF_UNUSED_FIELD") // temp
-public class AuthConfig {
-    public boolean enable = true;
-    public boolean onlineModeRequiresLogin = false;
-    public String table = "auth";
-}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/config/plugins/PluginsConfig.java b/proxy/src/main/java/ru/elytrium/elytraproxy/config/plugins/PluginsConfig.java
deleted file mode 100644
index 0110405c..00000000
--- a/proxy/src/main/java/ru/elytrium/elytraproxy/config/plugins/PluginsConfig.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (C) 2021 mdxd44 <banklazhan222>, hevav <Petr Ilin>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ru.elytrium.elytraproxy.config.plugins;
-
-import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
-
-@SuppressFBWarnings("UUF_UNUSED_FIELD") // temp
-public class PluginsConfig {
-    public AntibotConfig antibot = new AntibotConfig();
-    public AuthConfig auth = new AuthConfig();
-}
diff --git a/proxy/src/main/resources/default-elytraproxy.yml b/proxy/src/main/resources/default-elytraproxy.yml
index 5410c0d3..9943a16b 100644
--- a/proxy/src/main/resources/default-elytraproxy.yml
+++ b/proxy/src/main/resources/default-elytraproxy.yml
@@ -1,27 +1,10 @@
-#
-# Copyright (C) 2021 mdxd44 <banklazhan222>, hevav <Petr Ilin>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program.  If not, see <https://www.gnu.org/licenses/>.
-#
-
 prefix: "¬ß5¬ßl[Elytrium]"
 messages:
   error:
-    alreadyConnected: "–í—ã —É–∂–µ –ø–æ–¥–∫–ª—é—á–µ–Ω—ã –∫ —ç—Ç–æ–º—É —Å–µ—Ä–≤–µ—Ä—É\!"
-    alreadyConnectedProxy: "–ò–≥—Ä–æ–∫ —Å —Ç–∞–∫–∏–º –Ω–∏–∫–æ–º —É–∂–µ –∏–≥—Ä–∞–µ—Ç –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ\!"
-    alreadyConnecting: "–í—ã —É–∂–µ –ø–æ–¥–∫–ª—é—á–∞–µ—Ç–µ—Å—å –∫ —Å–µ—Ä–≤–µ—Ä—É\!"
-    cantConnect: "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ —Å–µ—Ä–≤–µ—Ä—É {0}\: {1}"
+    alreadyConnected: "–í—ã —É–∂–µ –ø–æ–¥–∫–ª—é—á–µ–Ω—ã –∫ —ç—Ç–æ–º—É —Å–µ—Ä–≤–µ—Ä—É!"
+    alreadyConnectedProxy: "–ò–≥—Ä–æ–∫ —Å —Ç–∞–∫–∏–º –Ω–∏–∫–æ–º —É–∂–µ –∏–≥—Ä–∞–µ—Ç –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ!"
+    alreadyConnecting: "–í—ã —É–∂–µ –ø–æ–¥–∫–ª—é—á–∞–µ—Ç–µ—Å—å –∫ —Å–µ—Ä–≤–µ—Ä—É!"
+    cantConnect: "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ —Å–µ—Ä–≤–µ—Ä—É {0}: {1}"
     connectingServerError: "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å –≤–∞—Å –∫ —Å–µ—Ä–≤–µ—Ä—É {0}. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ —á–µ—Ä–µ–∑ –Ω–µ–∫–æ—Ç–æ—Ä–æ–µ –≤—Ä–µ–º—è."
     connectedServerError: "–° –≤–∞—à–∏–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ–º –∫ —Å–µ—Ä–≤–µ—Ä—É {0} –≤–æ–∑–Ω–∏–∫–ª–∞ –ø—Ä–æ–±–ª–µ–º–∞."
     internalServerConnectionError: "–ù–∞ —Å–µ—Ä–≤–µ—Ä–µ –ø—Ä–æ–∏–∑–æ—à–ª–∞ –≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è."
@@ -30,7 +13,7 @@ messages:
     playerConnectionError: "–í –≤–∞—à–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏ –ø—Ä–æ–∏–∑–æ—à–ª–∞ –≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞."
     modernForwardingNeedsNewClient: "–≠—Ç–æ—Ç —Å–µ—Ä–≤–µ—Ä —Å–æ–≤–º–µ—Å—Ç–∏–º —Ç–æ–ª—å–∫–æ —Å Minecraft 1.13 –∏ –≤—ã—à–µ."
     modernForwardingFailed: "–í–∞—à —Å–µ—Ä–≤–µ—Ä –Ω–µ –ø–æ—Å—ã–ª–∞–ª –∑–∞–ø—Ä–æ—Å –Ω–∞ –ø–µ—Ä–µ–∞–¥—Ä–µ—Å–∞—Ü–∏—é –Ω–∞ –ø—Ä–æ–∫—Å–∏-—Å–µ—Ä–≤–µ—Ä. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —Å–µ—Ä–≤–µ—Ä –Ω–∞—Å—Ç—Ä–æ–µ–Ω –Ω–∞ –ø–µ—Ä–µ–∞–¥—Ä–µ—Å–∞—Ü–∏—é Velocity."
-    movedToNewServer: "–í—ã –±—ã–ª–∏ –∫–∏–∫–Ω—É—Ç—ã —Å —Å–µ—Ä–≤–µ—Ä–∞ {0}\: {1}"
+    movedToNewServer: "–í—ã –±—ã–ª–∏ –∫–∏–∫–Ω—É—Ç—ã —Å —Å–µ—Ä–≤–µ—Ä–∞ {0}: {1}"
     noAvailableServers: "–ù–µ—Ç —Å–µ—Ä–≤–µ—Ä–æ–≤, –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –¥–ª—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ –∏–ª–∏ —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º."
     configLoadFailed: "–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –æ–±—Ä–∞—Ç–∏—Ç—å—Å—è –∫ –∫–æ–Ω—Ñ–∏–≥-—Ñ–∞–π–ª—É elytraproxy.yml. –í—ã–∫–ª—é—á–µ–Ω–∏–µ..."
     mysqlLoadFailed: "–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö. –í—ã–∫–ª—é—á–µ–Ω–∏–µ..."
@@ -39,7 +22,7 @@ messages:
     commandDoesNotExist: "–≠—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç."
     serverDoesNotExist: "–£–∫–∞–∑–∞–Ω–Ω—ã–π —Å–µ—Ä–≤–µ—Ä {0} –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç."
     serverTooMany: "–ù–∞—Å—Ç—Ä–æ–µ–Ω–æ —Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ —Å–µ—Ä–≤–µ—Ä–æ–≤. –î–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –≤—Å–µ—Ö –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å–µ—Ä–≤–µ—Ä–æ–≤, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∞–≤—Ç–æ–∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –∫–ª–∞–≤–∏—à–µ–π Tab."
-    serverAvailable: "–î–æ—Å—Ç—É–ø–Ω—ã–µ —Å–µ—Ä–≤–µ—Ä—ã\:"
+    serverAvailable: "–î–æ—Å—Ç—É–ø–Ω—ã–µ —Å–µ—Ä–≤–µ—Ä—ã:"
     serverTooltipPlayerOnline: "{0} –∏–≥—Ä–æ–∫ –æ–Ω–ª–∞–π–Ω"
     serverTooltipPlayersOnline: "{0} –∏–≥—Ä–æ–∫(–∞, –æ–≤) –æ–Ω–ª–∞–π–Ω"
     serverTooltipCurrentServer: "–ü–æ–¥–∫–ª—é—á–µ–Ω –∫ —ç—Ç–æ–º—É —Å–µ—Ä–≤–µ—Ä—É"
@@ -48,11 +31,6 @@ messages:
     glistViewAll: "–ß—Ç–æ–±—ã –ø—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å –≤—Å–µ—Ö –∏–≥—Ä–æ–∫–æ–≤ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–∞—Ö, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ /glist all."
     reloadFailure: "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é Velocity. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∫–æ–Ω—Å–æ–ª—å –¥–ª—è –ø–æ–¥—Ä–æ–±–Ω–æ—Å—Ç–µ–π."
     versionCopyright: "Copyright 2018-2021 {0}. {1} –ª–∏—Ü–µ–Ω–∑–∏—Ä–æ–≤–∞–Ω–∞ –Ω–∞ —É—Å–ª–æ–≤–∏—è—Ö GNU General Public License v3."
-    noPlugins: "–ù–∏ –æ–¥–Ω–æ–≥–æ –ø–ª–∞–≥–∏–Ω–∞ –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ."
-    pluginsList: "–ü–ª–∞–≥–∏–Ω—ã\: {0}"
-    pluginTooltipWebsite: "–í–µ–±—Å–∞–π—Ç\: {0}"
-    pluginTooltipAuthor: "–ê–≤—Ç–æ—Ä\: {0}"
-    pluginTooltipAuthors: "–ê–≤—Ç–æ—Ä—ã\: {0}"
 mysql:
   hostname: "localhost:3306"
   user: "root"
diff --git a/proxy/src/test/java/com/velocitypowered/proxy/util/ratelimit/GuavaCacheRatelimiterTest.java b/proxy/src/test/java/com/velocitypowered/proxy/util/ratelimit/GuavaCacheRatelimiterTest.java
index 39f50e7f..7ed4618e 100644
--- a/proxy/src/test/java/com/velocitypowered/proxy/util/ratelimit/GuavaCacheRatelimiterTest.java
+++ b/proxy/src/test/java/com/velocitypowered/proxy/util/ratelimit/GuavaCacheRatelimiterTest.java
@@ -30,7 +30,13 @@ class GuavaCacheRatelimiterTest {
 
   @Test
   void attemptZero() {
-    Ratelimiter noRatelimiter = new GuavaCacheRatelimiter(0, TimeUnit.MILLISECONDS);
+    Ratelimiter noRatelimiter = Ratelimiters.createWithMilliseconds(0, 0);
+    assertTrue(noRatelimiter.attempt(InetAddress.getLoopbackAddress()));
+    assertTrue(noRatelimiter.attempt(InetAddress.getLoopbackAddress()));
+    noRatelimiter = Ratelimiters.createWithMilliseconds(0, 2);
+    assertTrue(noRatelimiter.attempt(InetAddress.getLoopbackAddress()));
+    assertTrue(noRatelimiter.attempt(InetAddress.getLoopbackAddress()));
+    noRatelimiter = Ratelimiters.createWithMilliseconds(20, 0);
     assertTrue(noRatelimiter.attempt(InetAddress.getLoopbackAddress()));
     assertTrue(noRatelimiter.attempt(InetAddress.getLoopbackAddress()));
   }
@@ -45,11 +51,50 @@ class GuavaCacheRatelimiterTest {
         return base + extra.get();
       }
     };
-    Ratelimiter ratelimiter = new GuavaCacheRatelimiter(1000, TimeUnit.MILLISECONDS, testTicker);
+    Ratelimiter ratelimiter = new GuavaCacheRatelimiter(1000, 3, TimeUnit.MILLISECONDS, testTicker);
+    assertTrue(ratelimiter.attempt(InetAddress.getLoopbackAddress()));
+    assertTrue(ratelimiter.attempt(InetAddress.getLoopbackAddress()));
     assertTrue(ratelimiter.attempt(InetAddress.getLoopbackAddress()));
     assertFalse(ratelimiter.attempt(InetAddress.getLoopbackAddress()));
     extra.addAndGet(TimeUnit.SECONDS.toNanos(2));
     assertTrue(ratelimiter.attempt(InetAddress.getLoopbackAddress()));
+    assertTrue(ratelimiter.attempt(InetAddress.getLoopbackAddress()));
+    assertTrue(ratelimiter.attempt(InetAddress.getLoopbackAddress()));
+    extra.addAndGet(TimeUnit.MILLISECONDS.toNanos(999));
+    assertFalse(ratelimiter.attempt(InetAddress.getLoopbackAddress()));
+    extra.addAndGet(TimeUnit.MILLISECONDS.toNanos(999));
+    assertFalse(ratelimiter.attempt(InetAddress.getLoopbackAddress()));
+    extra.addAndGet(TimeUnit.MILLISECONDS.toNanos(2));
+    assertTrue(ratelimiter.attempt(InetAddress.getLoopbackAddress()));
+    extra.addAndGet(TimeUnit.SECONDS.toNanos(2));
+    assertTrue(ratelimiter.attempt(InetAddress.getLoopbackAddress()));
+  }
+
+  @Test
+  void unthrottleTest() {
+    long base = System.nanoTime();
+    AtomicLong extra = new AtomicLong();
+    Ticker testTicker = new Ticker() {
+      @Override
+      public long read() {
+        return base + extra.get();
+      }
+    };
+    Ratelimiter ratelimiter = new GuavaCacheRatelimiter(1000, 3, TimeUnit.MILLISECONDS, testTicker);
+    assertTrue(ratelimiter.attempt(InetAddress.getLoopbackAddress()));
+    ratelimiter.unthrottle(InetAddress.getLoopbackAddress());
+    assertTrue(ratelimiter.attempt(InetAddress.getLoopbackAddress()));
+    ratelimiter.unthrottle(InetAddress.getLoopbackAddress());
+    assertTrue(ratelimiter.attempt(InetAddress.getLoopbackAddress()));
+    ratelimiter.unthrottle(InetAddress.getLoopbackAddress());
+    assertTrue(ratelimiter.attempt(InetAddress.getLoopbackAddress()));
+    ratelimiter.unthrottle(InetAddress.getLoopbackAddress());
+    assertTrue(ratelimiter.attempt(InetAddress.getLoopbackAddress()));
+    ratelimiter.unthrottle(InetAddress.getLoopbackAddress());
+    assertTrue(ratelimiter.attempt(InetAddress.getLoopbackAddress()));
+    assertTrue(ratelimiter.attempt(InetAddress.getLoopbackAddress()));
+    assertTrue(ratelimiter.attempt(InetAddress.getLoopbackAddress()));
+    assertFalse(ratelimiter.attempt(InetAddress.getLoopbackAddress()));
   }
 
 }
-- 
2.24.1.windows.2

